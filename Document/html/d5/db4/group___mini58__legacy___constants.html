<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MINI58_BSP: Mini58 Legacy Constants</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../M0Banner_v2.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">MINI58_BSP<span id="projectnumber">&#160;V3.02.000</span>
   </div>
   <div id="projectbrief">The Board Support Package for Mini58 Series MCU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Mini58 Legacy Constants<div class="ingroups"><a class="el" href="../../d8/d83/group___mini58___p_e_r_i_p_h_e_r_a_l___m_e_m___m_a_p.html">Mini58 Peripheral Memory Map</a> &raquo; <a class="el" href="../../da/d26/group___mini58___p_e_r_i_p_h_e_r_a_l___d_e_c_l_a_r_a_t_i_o_n.html">Mini58 Peripheral Declaration</a> &raquo; <a class="el" href="../../d6/d8c/group___mini58___i_o___r_o_u_t_i_n_e.html">Mini58 I/O Routines</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Mini58 Legacy Constants:</div>
<div class="dyncontent">
<div class="center"><img src="../../d5/db4/group___mini58__legacy___constants.png" border="0" usemap="#ad5_2db4_2group______mini58____legacy______constants" alt=""/></div>
<map name="ad5_2db4_2group______mini58____legacy______constants" id="ad5_2db4_2group______mini58____legacy______constants">
<area shape="rect" href="../../d6/d8c/group___mini58___i_o___r_o_u_t_i_n_e.html" title=" " alt="" coords="5,5,141,31"/>
<area shape="rect" title=" " alt="" coords="189,5,359,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga070d2ce7b6bb7e5c05602aa8c308d0c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga070d2ce7b6bb7e5c05602aa8c308d0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL pointer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">More...</a><br /></td></tr>
<tr class="separator:ga070d2ce7b6bb7e5c05602aa8c308d0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cecfc5c5c054d2875c03e77b7be15d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gaa8cecfc5c5c054d2875c03e77b7be15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean true, define to use in API parameters or return value.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gaa8cecfc5c5c054d2875c03e77b7be15d">More...</a><br /></td></tr>
<tr class="separator:gaa8cecfc5c5c054d2875c03e77b7be15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93f0eb578d23995850d61f7d61c55c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaa93f0eb578d23995850d61f7d61c55c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean false, define to use in API parameters or return value.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gaa93f0eb578d23995850d61f7d61c55c1">More...</a><br /></td></tr>
<tr class="separator:gaa93f0eb578d23995850d61f7d61c55c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514ad415fb6125ba296793df7d1a468a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga514ad415fb6125ba296793df7d1a468a">ENABLE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga514ad415fb6125ba296793df7d1a468a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable, define to use in API parameters.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga514ad415fb6125ba296793df7d1a468a">More...</a><br /></td></tr>
<tr class="separator:ga514ad415fb6125ba296793df7d1a468a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99496f7308834e8b220f7894efa0b6ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga99496f7308834e8b220f7894efa0b6ab">DISABLE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga99496f7308834e8b220f7894efa0b6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable, define to use in API parameters.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga99496f7308834e8b220f7894efa0b6ab">More...</a><br /></td></tr>
<tr class="separator:ga99496f7308834e8b220f7894efa0b6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d43f8748b542bce39e18790f845ecc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gad4d43f8748b542bce39e18790f845ecc">BIT0</a>&#160;&#160;&#160;(0x00000001)</td></tr>
<tr class="memdesc:gad4d43f8748b542bce39e18790f845ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 0 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gad4d43f8748b542bce39e18790f845ecc">More...</a><br /></td></tr>
<tr class="separator:gad4d43f8748b542bce39e18790f845ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601923eba46784638244c1ebf2622a2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga601923eba46784638244c1ebf2622a2a">BIT1</a>&#160;&#160;&#160;(0x00000002)</td></tr>
<tr class="memdesc:ga601923eba46784638244c1ebf2622a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 1 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga601923eba46784638244c1ebf2622a2a">More...</a><br /></td></tr>
<tr class="separator:ga601923eba46784638244c1ebf2622a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c9560bccccb00174801c728f1ed1399"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga9c9560bccccb00174801c728f1ed1399">BIT2</a>&#160;&#160;&#160;(0x00000004)</td></tr>
<tr class="memdesc:ga9c9560bccccb00174801c728f1ed1399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 2 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga9c9560bccccb00174801c728f1ed1399">More...</a><br /></td></tr>
<tr class="separator:ga9c9560bccccb00174801c728f1ed1399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e44574a8a8becc885b05f3bc367ef6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8e44574a8a8becc885b05f3bc367ef6a">BIT3</a>&#160;&#160;&#160;(0x00000008)</td></tr>
<tr class="memdesc:ga8e44574a8a8becc885b05f3bc367ef6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 3 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga8e44574a8a8becc885b05f3bc367ef6a">More...</a><br /></td></tr>
<tr class="separator:ga8e44574a8a8becc885b05f3bc367ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa731e0b6cf75f4e637ee88959315f5e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaa731e0b6cf75f4e637ee88959315f5e4">BIT4</a>&#160;&#160;&#160;(0x00000010)</td></tr>
<tr class="memdesc:gaa731e0b6cf75f4e637ee88959315f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 4 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gaa731e0b6cf75f4e637ee88959315f5e4">More...</a><br /></td></tr>
<tr class="separator:gaa731e0b6cf75f4e637ee88959315f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae692bc3df48028ceb1ddc2534a993bb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gae692bc3df48028ceb1ddc2534a993bb8">BIT5</a>&#160;&#160;&#160;(0x00000020)</td></tr>
<tr class="memdesc:gae692bc3df48028ceb1ddc2534a993bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 5 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gae692bc3df48028ceb1ddc2534a993bb8">More...</a><br /></td></tr>
<tr class="separator:gae692bc3df48028ceb1ddc2534a993bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2d074401e2b6322ee8f03476c24677"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gacc2d074401e2b6322ee8f03476c24677">BIT6</a>&#160;&#160;&#160;(0x00000040)</td></tr>
<tr class="memdesc:gacc2d074401e2b6322ee8f03476c24677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 6 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gacc2d074401e2b6322ee8f03476c24677">More...</a><br /></td></tr>
<tr class="separator:gacc2d074401e2b6322ee8f03476c24677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b8f3261ae9e2e1043380c192f7b5f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaa6b8f3261ae9e2e1043380c192f7b5f0">BIT7</a>&#160;&#160;&#160;(0x00000080)</td></tr>
<tr class="memdesc:gaa6b8f3261ae9e2e1043380c192f7b5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 7 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gaa6b8f3261ae9e2e1043380c192f7b5f0">More...</a><br /></td></tr>
<tr class="separator:gaa6b8f3261ae9e2e1043380c192f7b5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e80e65237843fa1ff15c68cd78066f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0e80e65237843fa1ff15c68cd78066f8">BIT8</a>&#160;&#160;&#160;(0x00000100)</td></tr>
<tr class="memdesc:ga0e80e65237843fa1ff15c68cd78066f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 8 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga0e80e65237843fa1ff15c68cd78066f8">More...</a><br /></td></tr>
<tr class="separator:ga0e80e65237843fa1ff15c68cd78066f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa20ab5eb33383fa31b0e94f4401cdf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga3aa20ab5eb33383fa31b0e94f4401cdf">BIT9</a>&#160;&#160;&#160;(0x00000200)</td></tr>
<tr class="memdesc:ga3aa20ab5eb33383fa31b0e94f4401cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 9 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga3aa20ab5eb33383fa31b0e94f4401cdf">More...</a><br /></td></tr>
<tr class="separator:ga3aa20ab5eb33383fa31b0e94f4401cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0f01fdf020d0f7467449b181fe95cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8c0f01fdf020d0f7467449b181fe95cb">BIT10</a>&#160;&#160;&#160;(0x00000400)</td></tr>
<tr class="memdesc:ga8c0f01fdf020d0f7467449b181fe95cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 10 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga8c0f01fdf020d0f7467449b181fe95cb">More...</a><br /></td></tr>
<tr class="separator:ga8c0f01fdf020d0f7467449b181fe95cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cda1debde057b596766eba6a76daca0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2cda1debde057b596766eba6a76daca0">BIT11</a>&#160;&#160;&#160;(0x00000800)</td></tr>
<tr class="memdesc:ga2cda1debde057b596766eba6a76daca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 11 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga2cda1debde057b596766eba6a76daca0">More...</a><br /></td></tr>
<tr class="separator:ga2cda1debde057b596766eba6a76daca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa0a6acba8436baabcaa1e91fad6c0bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaaa0a6acba8436baabcaa1e91fad6c0bd">BIT12</a>&#160;&#160;&#160;(0x00001000)</td></tr>
<tr class="memdesc:gaaa0a6acba8436baabcaa1e91fad6c0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 12 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gaaa0a6acba8436baabcaa1e91fad6c0bd">More...</a><br /></td></tr>
<tr class="separator:gaaa0a6acba8436baabcaa1e91fad6c0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga965dc1748ab1cf91426bd04a2fe16ecf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga965dc1748ab1cf91426bd04a2fe16ecf">BIT13</a>&#160;&#160;&#160;(0x00002000)</td></tr>
<tr class="memdesc:ga965dc1748ab1cf91426bd04a2fe16ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 13 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga965dc1748ab1cf91426bd04a2fe16ecf">More...</a><br /></td></tr>
<tr class="separator:ga965dc1748ab1cf91426bd04a2fe16ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e750b67eb36c8da10328c565b90dd5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga41e750b67eb36c8da10328c565b90dd5">BIT14</a>&#160;&#160;&#160;(0x00004000)</td></tr>
<tr class="memdesc:ga41e750b67eb36c8da10328c565b90dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 14 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga41e750b67eb36c8da10328c565b90dd5">More...</a><br /></td></tr>
<tr class="separator:ga41e750b67eb36c8da10328c565b90dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40f5db1c57c98c6db42f15e0a56f03a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gae40f5db1c57c98c6db42f15e0a56f03a">BIT15</a>&#160;&#160;&#160;(0x00008000)</td></tr>
<tr class="memdesc:gae40f5db1c57c98c6db42f15e0a56f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 15 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gae40f5db1c57c98c6db42f15e0a56f03a">More...</a><br /></td></tr>
<tr class="separator:gae40f5db1c57c98c6db42f15e0a56f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c55b9d74a6a1b129397792053cf08d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga7c55b9d74a6a1b129397792053cf08d5">BIT16</a>&#160;&#160;&#160;(0x00010000)</td></tr>
<tr class="memdesc:ga7c55b9d74a6a1b129397792053cf08d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 16 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga7c55b9d74a6a1b129397792053cf08d5">More...</a><br /></td></tr>
<tr class="separator:ga7c55b9d74a6a1b129397792053cf08d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27fe52b845a36280f50414ab4a00f74f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga27fe52b845a36280f50414ab4a00f74f">BIT17</a>&#160;&#160;&#160;(0x00020000)</td></tr>
<tr class="memdesc:ga27fe52b845a36280f50414ab4a00f74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 17 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga27fe52b845a36280f50414ab4a00f74f">More...</a><br /></td></tr>
<tr class="separator:ga27fe52b845a36280f50414ab4a00f74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a026d146963b7d977255d9b1f682ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga56a026d146963b7d977255d9b1f682ae">BIT18</a>&#160;&#160;&#160;(0x00040000)</td></tr>
<tr class="memdesc:ga56a026d146963b7d977255d9b1f682ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 18 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga56a026d146963b7d977255d9b1f682ae">More...</a><br /></td></tr>
<tr class="separator:ga56a026d146963b7d977255d9b1f682ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce58ae33c478370e59c915b04b05381"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga9ce58ae33c478370e59c915b04b05381">BIT19</a>&#160;&#160;&#160;(0x00080000)</td></tr>
<tr class="memdesc:ga9ce58ae33c478370e59c915b04b05381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 19 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga9ce58ae33c478370e59c915b04b05381">More...</a><br /></td></tr>
<tr class="separator:ga9ce58ae33c478370e59c915b04b05381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83aaba3456aa46dfefe199fe6264d8dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga83aaba3456aa46dfefe199fe6264d8dc">BIT20</a>&#160;&#160;&#160;(0x00100000)</td></tr>
<tr class="memdesc:ga83aaba3456aa46dfefe199fe6264d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 20 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga83aaba3456aa46dfefe199fe6264d8dc">More...</a><br /></td></tr>
<tr class="separator:ga83aaba3456aa46dfefe199fe6264d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5b4d4ca137f11bcb2e9c381f2ea6c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga1a5b4d4ca137f11bcb2e9c381f2ea6c5">BIT21</a>&#160;&#160;&#160;(0x00200000)</td></tr>
<tr class="memdesc:ga1a5b4d4ca137f11bcb2e9c381f2ea6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 21 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga1a5b4d4ca137f11bcb2e9c381f2ea6c5">More...</a><br /></td></tr>
<tr class="separator:ga1a5b4d4ca137f11bcb2e9c381f2ea6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdaa01ee37bdcd01ea44dbab6a30fd0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gafdaa01ee37bdcd01ea44dbab6a30fd0d">BIT22</a>&#160;&#160;&#160;(0x00400000)</td></tr>
<tr class="memdesc:gafdaa01ee37bdcd01ea44dbab6a30fd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 22 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gafdaa01ee37bdcd01ea44dbab6a30fd0d">More...</a><br /></td></tr>
<tr class="separator:gafdaa01ee37bdcd01ea44dbab6a30fd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada7be80971d1875e5c4774edd3ecd97d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gada7be80971d1875e5c4774edd3ecd97d">BIT23</a>&#160;&#160;&#160;(0x00800000)</td></tr>
<tr class="memdesc:gada7be80971d1875e5c4774edd3ecd97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 23 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gada7be80971d1875e5c4774edd3ecd97d">More...</a><br /></td></tr>
<tr class="separator:gada7be80971d1875e5c4774edd3ecd97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96cfb019bda32752ff4c8b8244aa6ea0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga96cfb019bda32752ff4c8b8244aa6ea0">BIT24</a>&#160;&#160;&#160;(0x01000000)</td></tr>
<tr class="memdesc:ga96cfb019bda32752ff4c8b8244aa6ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 24 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga96cfb019bda32752ff4c8b8244aa6ea0">More...</a><br /></td></tr>
<tr class="separator:ga96cfb019bda32752ff4c8b8244aa6ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3017291241a7269c1582154a3d3b1f09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga3017291241a7269c1582154a3d3b1f09">BIT25</a>&#160;&#160;&#160;(0x02000000)</td></tr>
<tr class="memdesc:ga3017291241a7269c1582154a3d3b1f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 25 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga3017291241a7269c1582154a3d3b1f09">More...</a><br /></td></tr>
<tr class="separator:ga3017291241a7269c1582154a3d3b1f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f97a8963cc15a1a50521d855b8a1331"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga4f97a8963cc15a1a50521d855b8a1331">BIT26</a>&#160;&#160;&#160;(0x04000000)</td></tr>
<tr class="memdesc:ga4f97a8963cc15a1a50521d855b8a1331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 26 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga4f97a8963cc15a1a50521d855b8a1331">More...</a><br /></td></tr>
<tr class="separator:ga4f97a8963cc15a1a50521d855b8a1331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd1584eaddf508717554b35a600b0fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gafdd1584eaddf508717554b35a600b0fd">BIT27</a>&#160;&#160;&#160;(0x08000000)</td></tr>
<tr class="memdesc:gafdd1584eaddf508717554b35a600b0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 27 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gafdd1584eaddf508717554b35a600b0fd">More...</a><br /></td></tr>
<tr class="separator:gafdd1584eaddf508717554b35a600b0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4361544977e96fb8eb8387ff0feaf6b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga4361544977e96fb8eb8387ff0feaf6b6">BIT28</a>&#160;&#160;&#160;(0x10000000)</td></tr>
<tr class="memdesc:ga4361544977e96fb8eb8387ff0feaf6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 28 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga4361544977e96fb8eb8387ff0feaf6b6">More...</a><br /></td></tr>
<tr class="separator:ga4361544977e96fb8eb8387ff0feaf6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb368e517e545da53d8aace5923649e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gadb368e517e545da53d8aace5923649e1">BIT29</a>&#160;&#160;&#160;(0x20000000)</td></tr>
<tr class="memdesc:gadb368e517e545da53d8aace5923649e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 29 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gadb368e517e545da53d8aace5923649e1">More...</a><br /></td></tr>
<tr class="separator:gadb368e517e545da53d8aace5923649e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70105c4a8c864754c8ba9e9b0e5da52a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga70105c4a8c864754c8ba9e9b0e5da52a">BIT30</a>&#160;&#160;&#160;(0x40000000)</td></tr>
<tr class="memdesc:ga70105c4a8c864754c8ba9e9b0e5da52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 30 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga70105c4a8c864754c8ba9e9b0e5da52a">More...</a><br /></td></tr>
<tr class="separator:ga70105c4a8c864754c8ba9e9b0e5da52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb09898dca36071e32cb1fbeec479e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gadfb09898dca36071e32cb1fbeec479e5">BIT31</a>&#160;&#160;&#160;(0x80000000)</td></tr>
<tr class="memdesc:gadfb09898dca36071e32cb1fbeec479e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit 31 mask of an 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#gadfb09898dca36071e32cb1fbeec479e5">More...</a><br /></td></tr>
<tr class="separator:gadfb09898dca36071e32cb1fbeec479e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da6b6038c3e29eb02a23385f7dfe18e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2da6b6038c3e29eb02a23385f7dfe18e">BYTE0_Msk</a>&#160;&#160;&#160;(0x000000FF)</td></tr>
<tr class="memdesc:ga2da6b6038c3e29eb02a23385f7dfe18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get bit0~bit7 from a 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga2da6b6038c3e29eb02a23385f7dfe18e">More...</a><br /></td></tr>
<tr class="separator:ga2da6b6038c3e29eb02a23385f7dfe18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdb45c3d1adab74d72eab6116f9581c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6bdb45c3d1adab74d72eab6116f9581c">BYTE1_Msk</a>&#160;&#160;&#160;(0x0000FF00)</td></tr>
<tr class="memdesc:ga6bdb45c3d1adab74d72eab6116f9581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get bit8~bit15 from a 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga6bdb45c3d1adab74d72eab6116f9581c">More...</a><br /></td></tr>
<tr class="separator:ga6bdb45c3d1adab74d72eab6116f9581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a926438abfcff696496c60ee5ebd4da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6a926438abfcff696496c60ee5ebd4da">BYTE2_Msk</a>&#160;&#160;&#160;(0x00FF0000)</td></tr>
<tr class="memdesc:ga6a926438abfcff696496c60ee5ebd4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get bit16~bit23 from a 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga6a926438abfcff696496c60ee5ebd4da">More...</a><br /></td></tr>
<tr class="separator:ga6a926438abfcff696496c60ee5ebd4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26cd8778bf420a922c9cd2bf7c916875"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga26cd8778bf420a922c9cd2bf7c916875">BYTE3_Msk</a>&#160;&#160;&#160;(0xFF000000)</td></tr>
<tr class="memdesc:ga26cd8778bf420a922c9cd2bf7c916875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get bit24~bit31 from a 32 bit integer.  <a href="../../d5/db4/group___mini58__legacy___constants.html#ga26cd8778bf420a922c9cd2bf7c916875">More...</a><br /></td></tr>
<tr class="separator:ga26cd8778bf420a922c9cd2bf7c916875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4adc89d1a476c51ae52eb700a06fb96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaf4adc89d1a476c51ae52eb700a06fb96">GET_BYTE0</a>(u32Param)&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2da6b6038c3e29eb02a23385f7dfe18e">BYTE0_Msk</a>)      )</td></tr>
<tr class="separator:gaf4adc89d1a476c51ae52eb700a06fb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61fd653ee8852ef7bb04fff1509febc8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga61fd653ee8852ef7bb04fff1509febc8">GET_BYTE1</a>(u32Param)&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6bdb45c3d1adab74d72eab6116f9581c">BYTE1_Msk</a>) &gt;&gt;  8)</td></tr>
<tr class="separator:ga61fd653ee8852ef7bb04fff1509febc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35d066854cc83e3823a21f9972fc308f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga35d066854cc83e3823a21f9972fc308f">GET_BYTE2</a>(u32Param)&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6a926438abfcff696496c60ee5ebd4da">BYTE2_Msk</a>) &gt;&gt; 16)</td></tr>
<tr class="separator:ga35d066854cc83e3823a21f9972fc308f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b580f1b27a79bb2b5924a40c9867ab4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2b580f1b27a79bb2b5924a40c9867ab4">GET_BYTE3</a>(u32Param)&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga26cd8778bf420a922c9cd2bf7c916875">BYTE3_Msk</a>) &gt;&gt; 24)</td></tr>
<tr class="separator:ga2b580f1b27a79bb2b5924a40c9867ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1c920595c6586bec644d46e2c1350b1c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga1c920595c6586bec644d46e2c1350b1c">ACMP_T::CTL</a> [2]</td></tr>
<tr class="separator:ga1c920595c6586bec644d46e2c1350b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6fa770a24a0372013c38701a9a4e4b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6c6fa770a24a0372013c38701a9a4e4b">ACMP_T::STATUS</a></td></tr>
<tr class="separator:ga6c6fa770a24a0372013c38701a9a4e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad821237c92ce9b8df69e97db76bd04e8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gad821237c92ce9b8df69e97db76bd04e8">ACMP_T::VREF</a></td></tr>
<tr class="separator:gad821237c92ce9b8df69e97db76bd04e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55dff1581fa36f47d3b1f629dc9f0695"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga55dff1581fa36f47d3b1f629dc9f0695">ADC_T::DAT</a></td></tr>
<tr class="separator:ga55dff1581fa36f47d3b1f629dc9f0695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a989c17bfe13704d599376218c9d93"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaa8a989c17bfe13704d599376218c9d93">ADC_T::CTL</a></td></tr>
<tr class="separator:gaa8a989c17bfe13704d599376218c9d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a552a9d8396e7a1a9c405359018a349"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8a552a9d8396e7a1a9c405359018a349">ADC_T::CHEN</a></td></tr>
<tr class="separator:ga8a552a9d8396e7a1a9c405359018a349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4756c188834873a45d077b6ca79f37c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaf4756c188834873a45d077b6ca79f37c">ADC_T::CMP0</a></td></tr>
<tr class="separator:gaf4756c188834873a45d077b6ca79f37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c0061430e3d538b92bd0cd493065bf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga92c0061430e3d538b92bd0cd493065bf">ADC_T::CMP1</a></td></tr>
<tr class="separator:ga92c0061430e3d538b92bd0cd493065bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga000cdb41ff688b3d840f8f3830a6298c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga000cdb41ff688b3d840f8f3830a6298c">ADC_T::STATUS</a></td></tr>
<tr class="separator:ga000cdb41ff688b3d840f8f3830a6298c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ad274ad68871fab0d061481079c4ec"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga26ad274ad68871fab0d061481079c4ec">ADC_T::TRGDLY</a></td></tr>
<tr class="separator:ga26ad274ad68871fab0d061481079c4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa44b3c2b019b385f646595a951c258a6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaa44b3c2b019b385f646595a951c258a6">ADC_T::EXTSMPT</a></td></tr>
<tr class="separator:gaa44b3c2b019b385f646595a951c258a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e86b3f633ef48ebbce59a38ada22b0d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga5e86b3f633ef48ebbce59a38ada22b0d">ADC_T::SEQCTL</a></td></tr>
<tr class="separator:ga5e86b3f633ef48ebbce59a38ada22b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b116c9fe25fae953000a3db56eddbc"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga45b116c9fe25fae953000a3db56eddbc">ADC_T::SEQDAT1</a></td></tr>
<tr class="separator:ga45b116c9fe25fae953000a3db56eddbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8757666587594e61e290ba49da4558a1"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8757666587594e61e290ba49da4558a1">ADC_T::SEQDAT2</a></td></tr>
<tr class="separator:ga8757666587594e61e290ba49da4558a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc40f2a57b0b379fd97dd6eecdba230"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8dc40f2a57b0b379fd97dd6eecdba230">CLK_T::PWRCTL</a></td></tr>
<tr class="separator:ga8dc40f2a57b0b379fd97dd6eecdba230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808b691f73f5988acf98189dc52c2258"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga808b691f73f5988acf98189dc52c2258">CLK_T::AHBCLK</a></td></tr>
<tr class="separator:ga808b691f73f5988acf98189dc52c2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab95b1d5348167498809cbe3d4afa7960"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gab95b1d5348167498809cbe3d4afa7960">CLK_T::APBCLK</a></td></tr>
<tr class="separator:gab95b1d5348167498809cbe3d4afa7960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8920dbbf2ea9a13672cd2811d4b2e84b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8920dbbf2ea9a13672cd2811d4b2e84b">CLK_T::STATUS</a></td></tr>
<tr class="separator:ga8920dbbf2ea9a13672cd2811d4b2e84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d0e2a48518b0d44641f594a763b619"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gae5d0e2a48518b0d44641f594a763b619">CLK_T::CLKSEL0</a></td></tr>
<tr class="separator:gae5d0e2a48518b0d44641f594a763b619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cad9e775d46b22aad65c5caa3ba9cbf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga9cad9e775d46b22aad65c5caa3ba9cbf">CLK_T::CLKSEL1</a></td></tr>
<tr class="separator:ga9cad9e775d46b22aad65c5caa3ba9cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f4848afe39a380101231bb0fd35d4d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gab3f4848afe39a380101231bb0fd35d4d">CLK_T::CLKDIV</a></td></tr>
<tr class="separator:gab3f4848afe39a380101231bb0fd35d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505ef1b8c8d11745b09418636c576b6f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga505ef1b8c8d11745b09418636c576b6f">CLK_T::CLKSEL2</a></td></tr>
<tr class="separator:ga505ef1b8c8d11745b09418636c576b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0059b5b729980b9dfe3a9cb3e75ea99a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0059b5b729980b9dfe3a9cb3e75ea99a">CLK_T::PLLCTL</a></td></tr>
<tr class="separator:ga0059b5b729980b9dfe3a9cb3e75ea99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d505afae945a248261c38c266a4deab"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga9d505afae945a248261c38c266a4deab">CLK_T::CLKOCTL</a></td></tr>
<tr class="separator:ga9d505afae945a248261c38c266a4deab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0599b0536ac7829ab7370046511eb94c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0599b0536ac7829ab7370046511eb94c">FMC_T::ISPCTL</a></td></tr>
<tr class="separator:ga0599b0536ac7829ab7370046511eb94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e74a55963b3f93f231054dc940a5be3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga3e74a55963b3f93f231054dc940a5be3">FMC_T::ISPADDR</a></td></tr>
<tr class="separator:ga3e74a55963b3f93f231054dc940a5be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a594f096446ee933113f6c57c200c3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga93a594f096446ee933113f6c57c200c3">FMC_T::ISPDAT</a></td></tr>
<tr class="separator:ga93a594f096446ee933113f6c57c200c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535eb6e9457c338ac7515a5d2ff06802"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga535eb6e9457c338ac7515a5d2ff06802">FMC_T::ISPCMD</a></td></tr>
<tr class="separator:ga535eb6e9457c338ac7515a5d2ff06802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef7c67979c87346e1de844a30b649269"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaef7c67979c87346e1de844a30b649269">FMC_T::ISPTRG</a></td></tr>
<tr class="separator:gaef7c67979c87346e1de844a30b649269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8147f850e50804a8dfe1021999a4d7db"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8147f850e50804a8dfe1021999a4d7db">FMC_T::DFBA</a></td></tr>
<tr class="separator:ga8147f850e50804a8dfe1021999a4d7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039cda92f876c6b845b86855765d60cd"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga039cda92f876c6b845b86855765d60cd">FMC_T::FATCTL</a></td></tr>
<tr class="separator:ga039cda92f876c6b845b86855765d60cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84712a01970a90ae3f2526fc53cb1998"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga84712a01970a90ae3f2526fc53cb1998">FMC_T::ISPSTS</a></td></tr>
<tr class="separator:ga84712a01970a90ae3f2526fc53cb1998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae04592bd9239c0732eb62847d146209f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gae04592bd9239c0732eb62847d146209f">GPIO_T::MODE</a></td></tr>
<tr class="separator:gae04592bd9239c0732eb62847d146209f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaab1b732a5fab67f022435f45d689ca3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaaab1b732a5fab67f022435f45d689ca3">GPIO_T::DINOFF</a></td></tr>
<tr class="separator:gaaab1b732a5fab67f022435f45d689ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacedf474a76d41eb49d93ca976fa0afa4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gacedf474a76d41eb49d93ca976fa0afa4">GPIO_T::DOUT</a></td></tr>
<tr class="separator:gacedf474a76d41eb49d93ca976fa0afa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210328cdbb34226b4526f2a302bdf19e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga210328cdbb34226b4526f2a302bdf19e">GPIO_T::DATMSK</a></td></tr>
<tr class="separator:ga210328cdbb34226b4526f2a302bdf19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd64ba4db747a13e65ee2ff1eaa0fe47"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gacd64ba4db747a13e65ee2ff1eaa0fe47">GPIO_T::PIN</a></td></tr>
<tr class="separator:gacd64ba4db747a13e65ee2ff1eaa0fe47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d4810bebd87d723aa1c2553576bc95"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gad3d4810bebd87d723aa1c2553576bc95">GPIO_T::DBEN</a></td></tr>
<tr class="separator:gad3d4810bebd87d723aa1c2553576bc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e1d37bb184d4c29c053078c22abec62"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2e1d37bb184d4c29c053078c22abec62">GPIO_T::INTTYPE</a></td></tr>
<tr class="separator:ga2e1d37bb184d4c29c053078c22abec62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2954225147cc4d89f9431fa5aeec33e2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2954225147cc4d89f9431fa5aeec33e2">GPIO_T::INTEN</a></td></tr>
<tr class="separator:ga2954225147cc4d89f9431fa5aeec33e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791263d0be410c056405a90bf7ff81c5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga791263d0be410c056405a90bf7ff81c5">GPIO_T::INTSRC</a></td></tr>
<tr class="separator:ga791263d0be410c056405a90bf7ff81c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85770c088c53797e0c7a2c04aff5aa04"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga85770c088c53797e0c7a2c04aff5aa04">GPIO_DB_T::DBCTL</a></td></tr>
<tr class="separator:ga85770c088c53797e0c7a2c04aff5aa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeaddca0794806b689834bdbeeaca072"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gabeaddca0794806b689834bdbeeaca072">I2C_T::CTL</a></td></tr>
<tr class="separator:gabeaddca0794806b689834bdbeeaca072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c4464dd2bbae8e455ec2a8939e0e173"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0c4464dd2bbae8e455ec2a8939e0e173">I2C_T::ADDR0</a></td></tr>
<tr class="separator:ga0c4464dd2bbae8e455ec2a8939e0e173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga158d79b640465c2687994504ceb19c42"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga158d79b640465c2687994504ceb19c42">I2C_T::DAT</a></td></tr>
<tr class="separator:ga158d79b640465c2687994504ceb19c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e9c068d3cc966e206bd45c9b04b074"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga45e9c068d3cc966e206bd45c9b04b074">I2C_T::STATUS</a></td></tr>
<tr class="separator:ga45e9c068d3cc966e206bd45c9b04b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ae778f266a41953e0d625b77c8f76f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga42ae778f266a41953e0d625b77c8f76f">I2C_T::CLKDIV</a></td></tr>
<tr class="separator:ga42ae778f266a41953e0d625b77c8f76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3195879cd62ffb1cef35e1a06313fbad"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga3195879cd62ffb1cef35e1a06313fbad">I2C_T::TOCTL</a></td></tr>
<tr class="separator:ga3195879cd62ffb1cef35e1a06313fbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga843a249954d4148ab862978604d15ddc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga843a249954d4148ab862978604d15ddc">I2C_T::ADDR1</a></td></tr>
<tr class="separator:ga843a249954d4148ab862978604d15ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2bd1ec04483ef731c3af8f0533675c0"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gab2bd1ec04483ef731c3af8f0533675c0">I2C_T::ADDR2</a></td></tr>
<tr class="separator:gab2bd1ec04483ef731c3af8f0533675c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d574a2ddedc447a5858ae7bcfdeb06"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga08d574a2ddedc447a5858ae7bcfdeb06">I2C_T::ADDR3</a></td></tr>
<tr class="separator:ga08d574a2ddedc447a5858ae7bcfdeb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd99cf51f40286f80175a8a9f1c0eb75"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gacd99cf51f40286f80175a8a9f1c0eb75">I2C_T::ADDRMSK0</a></td></tr>
<tr class="separator:gacd99cf51f40286f80175a8a9f1c0eb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c22b89fc5263ace1981c76d7a18aa11"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga7c22b89fc5263ace1981c76d7a18aa11">I2C_T::ADDRMSK1</a></td></tr>
<tr class="separator:ga7c22b89fc5263ace1981c76d7a18aa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe01f1b66375f7c09518dcb6de28e765"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gafe01f1b66375f7c09518dcb6de28e765">I2C_T::ADDRMSK2</a></td></tr>
<tr class="separator:gafe01f1b66375f7c09518dcb6de28e765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27aa65a6371d4411cd0e51060cc9b081"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga27aa65a6371d4411cd0e51060cc9b081">I2C_T::ADDRMSK3</a></td></tr>
<tr class="separator:ga27aa65a6371d4411cd0e51060cc9b081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709765ae65421d9d51aa7539684197ac"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga709765ae65421d9d51aa7539684197ac">I2C_T::CTL1</a></td></tr>
<tr class="separator:ga709765ae65421d9d51aa7539684197ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9030c603fea9963d088d0d20de4c1a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6c9030c603fea9963d088d0d20de4c1a">I2C_T::STATUS1</a></td></tr>
<tr class="separator:ga6c9030c603fea9963d088d0d20de4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91fce36f79cd65f12f58e9651f6f09d2"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga91fce36f79cd65f12f58e9651f6f09d2">INTR_T::IRQ0_SRC</a></td></tr>
<tr class="separator:ga91fce36f79cd65f12f58e9651f6f09d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7e99f775e86b07b2ba28727dde1961"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga7b7e99f775e86b07b2ba28727dde1961">INTR_T::IRQ1_SRC</a></td></tr>
<tr class="separator:ga7b7e99f775e86b07b2ba28727dde1961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga310daef4f69c58d2cdc6d292b51a982f"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga310daef4f69c58d2cdc6d292b51a982f">INTR_T::IRQ2_SRC</a></td></tr>
<tr class="separator:ga310daef4f69c58d2cdc6d292b51a982f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac37b01494b3e644ad8bd85caa40af0df"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gac37b01494b3e644ad8bd85caa40af0df">INTR_T::IRQ3_SRC</a></td></tr>
<tr class="separator:gac37b01494b3e644ad8bd85caa40af0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47be980853ed88f61819d0e82c639809"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga47be980853ed88f61819d0e82c639809">INTR_T::IRQ4_SRC</a></td></tr>
<tr class="separator:ga47be980853ed88f61819d0e82c639809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d89b8973976a13d75c7e90f4ef79a9a"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga7d89b8973976a13d75c7e90f4ef79a9a">INTR_T::IRQ5_SRC</a></td></tr>
<tr class="separator:ga7d89b8973976a13d75c7e90f4ef79a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a77cbbb6a3e73a3f7edae83ea1965ba"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6a77cbbb6a3e73a3f7edae83ea1965ba">INTR_T::IRQ6_SRC</a></td></tr>
<tr class="separator:ga6a77cbbb6a3e73a3f7edae83ea1965ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b3b2d0c8c58af07f8a2c41f50b11643"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga4b3b2d0c8c58af07f8a2c41f50b11643">INTR_T::IRQ7_SRC</a></td></tr>
<tr class="separator:ga4b3b2d0c8c58af07f8a2c41f50b11643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a8f99a682a9e1b4d2e5e941b377505b"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0a8f99a682a9e1b4d2e5e941b377505b">INTR_T::IRQ8_SRC</a></td></tr>
<tr class="separator:ga0a8f99a682a9e1b4d2e5e941b377505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1b7434688d5f24efc282ec7271973a"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gacb1b7434688d5f24efc282ec7271973a">INTR_T::IRQ9_SRC</a></td></tr>
<tr class="separator:gacb1b7434688d5f24efc282ec7271973a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59dc58587d2617882d8f9ca77c13b4a2"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga59dc58587d2617882d8f9ca77c13b4a2">INTR_T::IRQ12_SRC</a></td></tr>
<tr class="separator:ga59dc58587d2617882d8f9ca77c13b4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d308fe67c335bdcf181f53fe632acd"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga51d308fe67c335bdcf181f53fe632acd">INTR_T::IRQ13_SRC</a></td></tr>
<tr class="separator:ga51d308fe67c335bdcf181f53fe632acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869bfad4f8041ab28dad45ff023ebbcb"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga869bfad4f8041ab28dad45ff023ebbcb">INTR_T::IRQ14_SRC</a></td></tr>
<tr class="separator:ga869bfad4f8041ab28dad45ff023ebbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecdba956413b453f66d69ab6b127d9e"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaeecdba956413b453f66d69ab6b127d9e">INTR_T::IRQ16_SRC</a></td></tr>
<tr class="separator:gaeecdba956413b453f66d69ab6b127d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf45dfdd7b47098231d839313057e835"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaaf45dfdd7b47098231d839313057e835">INTR_T::IRQ17_SRC</a></td></tr>
<tr class="separator:gaaf45dfdd7b47098231d839313057e835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0639942505016e78cd35be5bb550771f"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0639942505016e78cd35be5bb550771f">INTR_T::IRQ18_SRC</a></td></tr>
<tr class="separator:ga0639942505016e78cd35be5bb550771f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3be0458e7fe6f6ccaf232c55d3b8f4e5"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga3be0458e7fe6f6ccaf232c55d3b8f4e5">INTR_T::IRQ19_SRC</a></td></tr>
<tr class="separator:ga3be0458e7fe6f6ccaf232c55d3b8f4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8be0f656d0b4c98d4c1571344cf0a2e"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gac8be0f656d0b4c98d4c1571344cf0a2e">INTR_T::IRQ25_SRC</a></td></tr>
<tr class="separator:gac8be0f656d0b4c98d4c1571344cf0a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0074102f9939059ab1daf7361ec5b75d"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0074102f9939059ab1daf7361ec5b75d">INTR_T::IRQ28_SRC</a></td></tr>
<tr class="separator:ga0074102f9939059ab1daf7361ec5b75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3553f04c068483737218a748e6e4cba"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gae3553f04c068483737218a748e6e4cba">INTR_T::IRQ29_SRC</a></td></tr>
<tr class="separator:gae3553f04c068483737218a748e6e4cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09268af0bfe8e5340cf8f297724a9f27"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga09268af0bfe8e5340cf8f297724a9f27">INTR_T::CON</a></td></tr>
<tr class="separator:ga09268af0bfe8e5340cf8f297724a9f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d20872bf4fccaed7e88b19fb4a3a50c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6d20872bf4fccaed7e88b19fb4a3a50c">INTR_T::IRQ</a></td></tr>
<tr class="separator:ga6d20872bf4fccaed7e88b19fb4a3a50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c901e81cfb5c40d77de799ea903246"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gac2c901e81cfb5c40d77de799ea903246">PWM_T::CLKPSC</a></td></tr>
<tr class="separator:gac2c901e81cfb5c40d77de799ea903246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4c6580a6e99fbd6faf507f730c2ec3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gabc4c6580a6e99fbd6faf507f730c2ec3">PWM_T::CLKDIV</a></td></tr>
<tr class="separator:gabc4c6580a6e99fbd6faf507f730c2ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5218f3d6ce38a982289ba890e94ebc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0a5218f3d6ce38a982289ba890e94ebc">PWM_T::CTL</a></td></tr>
<tr class="separator:ga0a5218f3d6ce38a982289ba890e94ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbcfb607febd5575d9614063438f7e9a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gadbcfb607febd5575d9614063438f7e9a">PWM_T::PERIOD0</a></td></tr>
<tr class="separator:gadbcfb607febd5575d9614063438f7e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae0d4237b99bac4e9d739c0da116c92"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaaae0d4237b99bac4e9d739c0da116c92">PWM_T::PERIOD1</a></td></tr>
<tr class="separator:gaaae0d4237b99bac4e9d739c0da116c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0603b2229e6c7d599c3a38363919fc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga5e0603b2229e6c7d599c3a38363919fc">PWM_T::PERIOD2</a></td></tr>
<tr class="separator:ga5e0603b2229e6c7d599c3a38363919fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5096612d276212791e563f235187dab6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga5096612d276212791e563f235187dab6">PWM_T::PERIOD3</a></td></tr>
<tr class="separator:ga5096612d276212791e563f235187dab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04f2a4f4e055fbec4012873272d6d90e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga04f2a4f4e055fbec4012873272d6d90e">PWM_T::PERIOD4</a></td></tr>
<tr class="separator:ga04f2a4f4e055fbec4012873272d6d90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d4238430a1480277cb7aef7120571a9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga5d4238430a1480277cb7aef7120571a9">PWM_T::PERIOD5</a></td></tr>
<tr class="separator:ga5d4238430a1480277cb7aef7120571a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c05a16118a0d1c2d76c81856e16802"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gab7c05a16118a0d1c2d76c81856e16802">PWM_T::CMPDAT0</a></td></tr>
<tr class="separator:gab7c05a16118a0d1c2d76c81856e16802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213a53325a0263f913f88f22fb5a2e5b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga213a53325a0263f913f88f22fb5a2e5b">PWM_T::CMPDAT1</a></td></tr>
<tr class="separator:ga213a53325a0263f913f88f22fb5a2e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a75a4f2a04ab1ecbc986d8913dc9c1e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8a75a4f2a04ab1ecbc986d8913dc9c1e">PWM_T::CMPDAT2</a></td></tr>
<tr class="separator:ga8a75a4f2a04ab1ecbc986d8913dc9c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ccf8537af74bc24277096f3e8f5eae"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga01ccf8537af74bc24277096f3e8f5eae">PWM_T::CMPDAT3</a></td></tr>
<tr class="separator:ga01ccf8537af74bc24277096f3e8f5eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ffc95951bedea134bb5b3506e8ed5c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gab0ffc95951bedea134bb5b3506e8ed5c">PWM_T::CMPDAT4</a></td></tr>
<tr class="separator:gab0ffc95951bedea134bb5b3506e8ed5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d422a9662172c36a3b468165496a1c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga76d422a9662172c36a3b468165496a1c">PWM_T::CMPDAT5</a></td></tr>
<tr class="separator:ga76d422a9662172c36a3b468165496a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fbc063a076e84e9b8f17ebcee04879e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga1fbc063a076e84e9b8f17ebcee04879e">PWM_T::INTEN</a></td></tr>
<tr class="separator:ga1fbc063a076e84e9b8f17ebcee04879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac535addafa0eb3c00a1fba2f4d845451"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gac535addafa0eb3c00a1fba2f4d845451">PWM_T::INTSTS</a></td></tr>
<tr class="separator:gac535addafa0eb3c00a1fba2f4d845451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f67a013b10cb1eaa23348156c5b3171"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2f67a013b10cb1eaa23348156c5b3171">PWM_T::POEN</a></td></tr>
<tr class="separator:ga2f67a013b10cb1eaa23348156c5b3171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b53247ddc0ba63aa01fa93d73f5e1ed"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2b53247ddc0ba63aa01fa93d73f5e1ed">PWM_T::BRKCTL</a></td></tr>
<tr class="separator:ga2b53247ddc0ba63aa01fa93d73f5e1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1392cfa1ca77df4619334c2f8133a9f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gae1392cfa1ca77df4619334c2f8133a9f">PWM_T::DTCTL</a></td></tr>
<tr class="separator:gae1392cfa1ca77df4619334c2f8133a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcf3338bdcd44ad7c3d2c604b8df3a0"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga5dcf3338bdcd44ad7c3d2c604b8df3a0">PWM_T::ADCTCTL0</a></td></tr>
<tr class="separator:ga5dcf3338bdcd44ad7c3d2c604b8df3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16289df68a4d0c4d7e1e5ac164474b57"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga16289df68a4d0c4d7e1e5ac164474b57">PWM_T::ADCTCTL1</a></td></tr>
<tr class="separator:ga16289df68a4d0c4d7e1e5ac164474b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fef052f7e6f31ba414b6ebd59af1293"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga5fef052f7e6f31ba414b6ebd59af1293">PWM_T::ADCTSTS0</a></td></tr>
<tr class="separator:ga5fef052f7e6f31ba414b6ebd59af1293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a6a18da1fc9adce379c1635f7723b5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga40a6a18da1fc9adce379c1635f7723b5">PWM_T::ADCTSTS1</a></td></tr>
<tr class="separator:ga40a6a18da1fc9adce379c1635f7723b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac16ad4728fef0e6e932b4a344ecbf33f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gac16ad4728fef0e6e932b4a344ecbf33f">PWM_T::PHCHG</a></td></tr>
<tr class="separator:gac16ad4728fef0e6e932b4a344ecbf33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d356a2be6cfaeb9c2f62626e8e8601"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gac8d356a2be6cfaeb9c2f62626e8e8601">PWM_T::PHCHGNXT</a></td></tr>
<tr class="separator:gac8d356a2be6cfaeb9c2f62626e8e8601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b5faca3f91ca97e0efe65b3a6115af"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga38b5faca3f91ca97e0efe65b3a6115af">PWM_T::PHCHGMSK</a></td></tr>
<tr class="separator:ga38b5faca3f91ca97e0efe65b3a6115af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf244c7a0518aff801a61660751055701"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaf244c7a0518aff801a61660751055701">PWM_T::IFA</a></td></tr>
<tr class="separator:gaf244c7a0518aff801a61660751055701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1f574b481deedb607735d2c773b3179"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gac1f574b481deedb607735d2c773b3179">PWM_T::PCACTL</a></td></tr>
<tr class="separator:gac1f574b481deedb607735d2c773b3179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd26661e05de9c177033c429c351d4b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gafdd26661e05de9c177033c429c351d4b">PWM_T::MSKALIGN</a></td></tr>
<tr class="separator:gafdd26661e05de9c177033c429c351d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069fd6acdea1842f24bba35267ff3ea5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga069fd6acdea1842f24bba35267ff3ea5">SPI_T::CTL</a></td></tr>
<tr class="separator:ga069fd6acdea1842f24bba35267ff3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea1e761f8c180884bc051c73db22e13"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6ea1e761f8c180884bc051c73db22e13">SPI_T::CLKDIV</a></td></tr>
<tr class="separator:ga6ea1e761f8c180884bc051c73db22e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab048babf359e75b9245fda37e24f5e8f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gab048babf359e75b9245fda37e24f5e8f">SPI_T::SSCTL</a></td></tr>
<tr class="separator:gab048babf359e75b9245fda37e24f5e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga037f046c43f269db9625dd1fc13b5392"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga037f046c43f269db9625dd1fc13b5392">SPI_T::RX</a></td></tr>
<tr class="separator:ga037f046c43f269db9625dd1fc13b5392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc2ae73eb2150a611415d9daa5fcdec"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga3bc2ae73eb2150a611415d9daa5fcdec">SPI_T::TX</a></td></tr>
<tr class="separator:ga3bc2ae73eb2150a611415d9daa5fcdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6477ea2c2d420604feccb3c1b62e593"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gab6477ea2c2d420604feccb3c1b62e593">SPI_T::SLVCTL</a></td></tr>
<tr class="separator:gab6477ea2c2d420604feccb3c1b62e593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ea825ffc93dccfd0ef04d389fc38e52"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8ea825ffc93dccfd0ef04d389fc38e52">SPI_T::FIFOCTL</a></td></tr>
<tr class="separator:ga8ea825ffc93dccfd0ef04d389fc38e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afe2cb0c518f0dff54c05986b987f33"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga4afe2cb0c518f0dff54c05986b987f33">SPI_T::STATUS</a></td></tr>
<tr class="separator:ga4afe2cb0c518f0dff54c05986b987f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6246fa552c418eb242d8bb15ebb045ba"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6246fa552c418eb242d8bb15ebb045ba">SYS_T::PDID</a></td></tr>
<tr class="separator:ga6246fa552c418eb242d8bb15ebb045ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3b921bb87def94dcc5dd252c6fd85d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gadf3b921bb87def94dcc5dd252c6fd85d">SYS_T::RSTSTS</a></td></tr>
<tr class="separator:gadf3b921bb87def94dcc5dd252c6fd85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe3faafb786240ac95352ee0167f39d2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gabe3faafb786240ac95352ee0167f39d2">SYS_T::IPRST0</a></td></tr>
<tr class="separator:gabe3faafb786240ac95352ee0167f39d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga662c5e1c1f6c3ab1ffcde33b072115e9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga662c5e1c1f6c3ab1ffcde33b072115e9">SYS_T::IPRST1</a></td></tr>
<tr class="separator:ga662c5e1c1f6c3ab1ffcde33b072115e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcc1733dcd63d84da44ae4c75f6312b2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gabcc1733dcd63d84da44ae4c75f6312b2">SYS_T::BODCTL</a></td></tr>
<tr class="separator:gabcc1733dcd63d84da44ae4c75f6312b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dcd32bdbde53be1c208b7171e05a25d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8dcd32bdbde53be1c208b7171e05a25d">SYS_T::P0_MFP</a></td></tr>
<tr class="separator:ga8dcd32bdbde53be1c208b7171e05a25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0e49256798068ee1ddb329a6c6eea1e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gae0e49256798068ee1ddb329a6c6eea1e">SYS_T::P1_MFP</a></td></tr>
<tr class="separator:gae0e49256798068ee1ddb329a6c6eea1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d2fa8ba015afa226505d64b0a7aa4c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga09d2fa8ba015afa226505d64b0a7aa4c">SYS_T::P2_MFP</a></td></tr>
<tr class="separator:ga09d2fa8ba015afa226505d64b0a7aa4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7400c0a92f4d16539f3d6acacd4795d1"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga7400c0a92f4d16539f3d6acacd4795d1">SYS_T::P3_MFP</a></td></tr>
<tr class="separator:ga7400c0a92f4d16539f3d6acacd4795d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12e8207e4aa7a748e6c9d6d63281416"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gad12e8207e4aa7a748e6c9d6d63281416">SYS_T::P4_MFP</a></td></tr>
<tr class="separator:gad12e8207e4aa7a748e6c9d6d63281416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26fcb8d118fa976019657257dbdb9876"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga26fcb8d118fa976019657257dbdb9876">SYS_T::P5_MFP</a></td></tr>
<tr class="separator:ga26fcb8d118fa976019657257dbdb9876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb4afd6bca8d31adb2a95a132d8f333"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaceb4afd6bca8d31adb2a95a132d8f333">SYS_T::IRCTCTL</a></td></tr>
<tr class="separator:gaceb4afd6bca8d31adb2a95a132d8f333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a9989e7170001ca5890978cac52278"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga00a9989e7170001ca5890978cac52278">SYS_T::IRCTIEN</a></td></tr>
<tr class="separator:ga00a9989e7170001ca5890978cac52278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d51c3dfb45b714c7eefb9f1d789abc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga43d51c3dfb45b714c7eefb9f1d789abc">SYS_T::IRCTISTS</a></td></tr>
<tr class="separator:ga43d51c3dfb45b714c7eefb9f1d789abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e2bb002e04a7eec46d6d2d324d3ce9b"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga7e2bb002e04a7eec46d6d2d324d3ce9b">SYS_T::REGLCTL</a></td></tr>
<tr class="separator:ga7e2bb002e04a7eec46d6d2d324d3ce9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb8d9df4695b742a04b52a7a64594322"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gabb8d9df4695b742a04b52a7a64594322">TIMER_T::CTL</a></td></tr>
<tr class="separator:gabb8d9df4695b742a04b52a7a64594322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2816828e99d2aec59a5484bfb0d02624"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2816828e99d2aec59a5484bfb0d02624">TIMER_T::CMP</a></td></tr>
<tr class="separator:ga2816828e99d2aec59a5484bfb0d02624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc9a19e31d66f608b9008c8c0f31eb8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gabfc9a19e31d66f608b9008c8c0f31eb8">TIMER_T::INTSTS</a></td></tr>
<tr class="separator:gabfc9a19e31d66f608b9008c8c0f31eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2463dd197cada9380f6dcb2fff23f2b"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaf2463dd197cada9380f6dcb2fff23f2b">TIMER_T::CNT</a></td></tr>
<tr class="separator:gaf2463dd197cada9380f6dcb2fff23f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd06cb4142a738d725637c4fa66caff"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga4dd06cb4142a738d725637c4fa66caff">TIMER_T::CAP</a></td></tr>
<tr class="separator:ga4dd06cb4142a738d725637c4fa66caff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4873e6bfb7ee6a7bf36a4a0d4d9f4f9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gae4873e6bfb7ee6a7bf36a4a0d4d9f4f9">TIMER_T::EXTCTL</a></td></tr>
<tr class="separator:gae4873e6bfb7ee6a7bf36a4a0d4d9f4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b29c334e8055b04d7248ab845ee99b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga22b29c334e8055b04d7248ab845ee99b">TIMER_T::EINTSTS</a></td></tr>
<tr class="separator:ga22b29c334e8055b04d7248ab845ee99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24820b94bbd2706f85d2bbed473fbd2c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga24820b94bbd2706f85d2bbed473fbd2c">UART_T::DAT</a></td></tr>
<tr class="separator:ga24820b94bbd2706f85d2bbed473fbd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0418d4cfbebf1037e83200b1d2e91ad3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0418d4cfbebf1037e83200b1d2e91ad3">UART_T::INTEN</a></td></tr>
<tr class="separator:ga0418d4cfbebf1037e83200b1d2e91ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a2724052e91db61cb0437ff9716bca2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga8a2724052e91db61cb0437ff9716bca2">UART_T::FIFO</a></td></tr>
<tr class="separator:ga8a2724052e91db61cb0437ff9716bca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374e1f1945b9df2e8e2a582729b07d99"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga374e1f1945b9df2e8e2a582729b07d99">UART_T::LINE</a></td></tr>
<tr class="separator:ga374e1f1945b9df2e8e2a582729b07d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa1ead360982a4a7e1ad1c372584fe1"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaafa1ead360982a4a7e1ad1c372584fe1">UART_T::MODEM</a></td></tr>
<tr class="separator:gaafa1ead360982a4a7e1ad1c372584fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4d0fc0b816b782c91353cbd62fac73"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2b4d0fc0b816b782c91353cbd62fac73">UART_T::MODEMSTS</a></td></tr>
<tr class="separator:ga2b4d0fc0b816b782c91353cbd62fac73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga611e6f66dfde1440b9fdc846731b5c49"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga611e6f66dfde1440b9fdc846731b5c49">UART_T::FIFOSTS</a></td></tr>
<tr class="separator:ga611e6f66dfde1440b9fdc846731b5c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e9084b9945be30518cb97148eb78ea"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gae7e9084b9945be30518cb97148eb78ea">UART_T::INTSTS</a></td></tr>
<tr class="separator:gae7e9084b9945be30518cb97148eb78ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867050f2a4553c426a3e7a35e7731825"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga867050f2a4553c426a3e7a35e7731825">UART_T::TOUT</a></td></tr>
<tr class="separator:ga867050f2a4553c426a3e7a35e7731825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca01dcd16be120667b8ec1b940b2800"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0ca01dcd16be120667b8ec1b940b2800">UART_T::BAUD</a></td></tr>
<tr class="separator:ga0ca01dcd16be120667b8ec1b940b2800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea733efcc748349d58440f9e424e3ef"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga0ea733efcc748349d58440f9e424e3ef">UART_T::IRDA</a></td></tr>
<tr class="separator:ga0ea733efcc748349d58440f9e424e3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e91cb2e6d95c030ce2add25e7c39e4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gad0e91cb2e6d95c030ce2add25e7c39e4">UART_T::ALTCTL</a></td></tr>
<tr class="separator:gad0e91cb2e6d95c030ce2add25e7c39e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a02d5c7120ffa3e209cdafcf7e97f03"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2a02d5c7120ffa3e209cdafcf7e97f03">UART_T::FUNSEL</a></td></tr>
<tr class="separator:ga2a02d5c7120ffa3e209cdafcf7e97f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8e65be2579f6ca7675e9a63886ab42"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gaee8e65be2579f6ca7675e9a63886ab42">WDT_T::CTL</a></td></tr>
<tr class="separator:gaee8e65be2579f6ca7675e9a63886ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6162b733283b23b1fc81bdb2ab6a9ef9"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6162b733283b23b1fc81bdb2ab6a9ef9">WDT_T::ALTCTL</a></td></tr>
<tr class="separator:ga6162b733283b23b1fc81bdb2ab6a9ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501fa437f75d2cfbcedb28e1703eacd4"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga501fa437f75d2cfbcedb28e1703eacd4">WWDT_T::RLDCNT</a></td></tr>
<tr class="separator:ga501fa437f75d2cfbcedb28e1703eacd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cb6657ceeced88c80688cc910e43e60"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga9cb6657ceeced88c80688cc910e43e60">WWDT_T::CTL</a></td></tr>
<tr class="separator:ga9cb6657ceeced88c80688cc910e43e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0ba9ab7857275c7d7d9d9d2c78cdd7"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2e0ba9ab7857275c7d7d9d9d2c78cdd7">WWDT_T::STATUS</a></td></tr>
<tr class="separator:ga2e0ba9ab7857275c7d7d9d9d2c78cdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaff670a5cd05add2f25ebe61a99727a"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#gacaff670a5cd05add2f25ebe61a99727a">WWDT_T::CNT</a></td></tr>
<tr class="separator:gacaff670a5cd05add2f25ebe61a99727a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Mini58 Legacy Constants </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad4d43f8748b542bce39e18790f845ecc" name="gad4d43f8748b542bce39e18790f845ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d43f8748b542bce39e18790f845ecc">&#9670;&nbsp;</a></span>BIT0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT0&#160;&#160;&#160;(0x00000001)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 0 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11896">11896</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga601923eba46784638244c1ebf2622a2a" name="ga601923eba46784638244c1ebf2622a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga601923eba46784638244c1ebf2622a2a">&#9670;&nbsp;</a></span>BIT1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT1&#160;&#160;&#160;(0x00000002)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 1 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11897">11897</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8c0f01fdf020d0f7467449b181fe95cb" name="ga8c0f01fdf020d0f7467449b181fe95cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0f01fdf020d0f7467449b181fe95cb">&#9670;&nbsp;</a></span>BIT10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT10&#160;&#160;&#160;(0x00000400)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 10 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11906">11906</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2cda1debde057b596766eba6a76daca0" name="ga2cda1debde057b596766eba6a76daca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cda1debde057b596766eba6a76daca0">&#9670;&nbsp;</a></span>BIT11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT11&#160;&#160;&#160;(0x00000800)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 11 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11907">11907</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaaa0a6acba8436baabcaa1e91fad6c0bd" name="gaaa0a6acba8436baabcaa1e91fad6c0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa0a6acba8436baabcaa1e91fad6c0bd">&#9670;&nbsp;</a></span>BIT12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT12&#160;&#160;&#160;(0x00001000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 12 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11908">11908</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga965dc1748ab1cf91426bd04a2fe16ecf" name="ga965dc1748ab1cf91426bd04a2fe16ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga965dc1748ab1cf91426bd04a2fe16ecf">&#9670;&nbsp;</a></span>BIT13</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT13&#160;&#160;&#160;(0x00002000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 13 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11909">11909</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga41e750b67eb36c8da10328c565b90dd5" name="ga41e750b67eb36c8da10328c565b90dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e750b67eb36c8da10328c565b90dd5">&#9670;&nbsp;</a></span>BIT14</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT14&#160;&#160;&#160;(0x00004000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 14 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11910">11910</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gae40f5db1c57c98c6db42f15e0a56f03a" name="gae40f5db1c57c98c6db42f15e0a56f03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40f5db1c57c98c6db42f15e0a56f03a">&#9670;&nbsp;</a></span>BIT15</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT15&#160;&#160;&#160;(0x00008000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 15 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11911">11911</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga7c55b9d74a6a1b129397792053cf08d5" name="ga7c55b9d74a6a1b129397792053cf08d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c55b9d74a6a1b129397792053cf08d5">&#9670;&nbsp;</a></span>BIT16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT16&#160;&#160;&#160;(0x00010000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 16 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11912">11912</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga27fe52b845a36280f50414ab4a00f74f" name="ga27fe52b845a36280f50414ab4a00f74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27fe52b845a36280f50414ab4a00f74f">&#9670;&nbsp;</a></span>BIT17</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT17&#160;&#160;&#160;(0x00020000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 17 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11913">11913</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga56a026d146963b7d977255d9b1f682ae" name="ga56a026d146963b7d977255d9b1f682ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a026d146963b7d977255d9b1f682ae">&#9670;&nbsp;</a></span>BIT18</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT18&#160;&#160;&#160;(0x00040000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 18 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11914">11914</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga9ce58ae33c478370e59c915b04b05381" name="ga9ce58ae33c478370e59c915b04b05381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ce58ae33c478370e59c915b04b05381">&#9670;&nbsp;</a></span>BIT19</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT19&#160;&#160;&#160;(0x00080000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 19 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11915">11915</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga9c9560bccccb00174801c728f1ed1399" name="ga9c9560bccccb00174801c728f1ed1399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c9560bccccb00174801c728f1ed1399">&#9670;&nbsp;</a></span>BIT2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT2&#160;&#160;&#160;(0x00000004)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 2 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11898">11898</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga83aaba3456aa46dfefe199fe6264d8dc" name="ga83aaba3456aa46dfefe199fe6264d8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83aaba3456aa46dfefe199fe6264d8dc">&#9670;&nbsp;</a></span>BIT20</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT20&#160;&#160;&#160;(0x00100000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 20 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11916">11916</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga1a5b4d4ca137f11bcb2e9c381f2ea6c5" name="ga1a5b4d4ca137f11bcb2e9c381f2ea6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a5b4d4ca137f11bcb2e9c381f2ea6c5">&#9670;&nbsp;</a></span>BIT21</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT21&#160;&#160;&#160;(0x00200000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 21 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11917">11917</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gafdaa01ee37bdcd01ea44dbab6a30fd0d" name="gafdaa01ee37bdcd01ea44dbab6a30fd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdaa01ee37bdcd01ea44dbab6a30fd0d">&#9670;&nbsp;</a></span>BIT22</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT22&#160;&#160;&#160;(0x00400000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 22 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11918">11918</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gada7be80971d1875e5c4774edd3ecd97d" name="gada7be80971d1875e5c4774edd3ecd97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada7be80971d1875e5c4774edd3ecd97d">&#9670;&nbsp;</a></span>BIT23</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT23&#160;&#160;&#160;(0x00800000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 23 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11919">11919</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga96cfb019bda32752ff4c8b8244aa6ea0" name="ga96cfb019bda32752ff4c8b8244aa6ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96cfb019bda32752ff4c8b8244aa6ea0">&#9670;&nbsp;</a></span>BIT24</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT24&#160;&#160;&#160;(0x01000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 24 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11920">11920</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga3017291241a7269c1582154a3d3b1f09" name="ga3017291241a7269c1582154a3d3b1f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3017291241a7269c1582154a3d3b1f09">&#9670;&nbsp;</a></span>BIT25</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT25&#160;&#160;&#160;(0x02000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 25 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11921">11921</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga4f97a8963cc15a1a50521d855b8a1331" name="ga4f97a8963cc15a1a50521d855b8a1331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f97a8963cc15a1a50521d855b8a1331">&#9670;&nbsp;</a></span>BIT26</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT26&#160;&#160;&#160;(0x04000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 26 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11922">11922</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gafdd1584eaddf508717554b35a600b0fd" name="gafdd1584eaddf508717554b35a600b0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdd1584eaddf508717554b35a600b0fd">&#9670;&nbsp;</a></span>BIT27</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT27&#160;&#160;&#160;(0x08000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 27 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11923">11923</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga4361544977e96fb8eb8387ff0feaf6b6" name="ga4361544977e96fb8eb8387ff0feaf6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4361544977e96fb8eb8387ff0feaf6b6">&#9670;&nbsp;</a></span>BIT28</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT28&#160;&#160;&#160;(0x10000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 28 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11924">11924</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gadb368e517e545da53d8aace5923649e1" name="gadb368e517e545da53d8aace5923649e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb368e517e545da53d8aace5923649e1">&#9670;&nbsp;</a></span>BIT29</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT29&#160;&#160;&#160;(0x20000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 29 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11925">11925</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8e44574a8a8becc885b05f3bc367ef6a" name="ga8e44574a8a8becc885b05f3bc367ef6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e44574a8a8becc885b05f3bc367ef6a">&#9670;&nbsp;</a></span>BIT3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT3&#160;&#160;&#160;(0x00000008)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 3 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11899">11899</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga70105c4a8c864754c8ba9e9b0e5da52a" name="ga70105c4a8c864754c8ba9e9b0e5da52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70105c4a8c864754c8ba9e9b0e5da52a">&#9670;&nbsp;</a></span>BIT30</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT30&#160;&#160;&#160;(0x40000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 30 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11926">11926</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gadfb09898dca36071e32cb1fbeec479e5" name="gadfb09898dca36071e32cb1fbeec479e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfb09898dca36071e32cb1fbeec479e5">&#9670;&nbsp;</a></span>BIT31</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT31&#160;&#160;&#160;(0x80000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 31 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11927">11927</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaa731e0b6cf75f4e637ee88959315f5e4" name="gaa731e0b6cf75f4e637ee88959315f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa731e0b6cf75f4e637ee88959315f5e4">&#9670;&nbsp;</a></span>BIT4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT4&#160;&#160;&#160;(0x00000010)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 4 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11900">11900</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gae692bc3df48028ceb1ddc2534a993bb8" name="gae692bc3df48028ceb1ddc2534a993bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae692bc3df48028ceb1ddc2534a993bb8">&#9670;&nbsp;</a></span>BIT5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT5&#160;&#160;&#160;(0x00000020)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 5 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11901">11901</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gacc2d074401e2b6322ee8f03476c24677" name="gacc2d074401e2b6322ee8f03476c24677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc2d074401e2b6322ee8f03476c24677">&#9670;&nbsp;</a></span>BIT6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT6&#160;&#160;&#160;(0x00000040)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 6 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11902">11902</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaa6b8f3261ae9e2e1043380c192f7b5f0" name="gaa6b8f3261ae9e2e1043380c192f7b5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6b8f3261ae9e2e1043380c192f7b5f0">&#9670;&nbsp;</a></span>BIT7</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT7&#160;&#160;&#160;(0x00000080)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 7 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11903">11903</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0e80e65237843fa1ff15c68cd78066f8" name="ga0e80e65237843fa1ff15c68cd78066f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e80e65237843fa1ff15c68cd78066f8">&#9670;&nbsp;</a></span>BIT8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT8&#160;&#160;&#160;(0x00000100)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 8 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11904">11904</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga3aa20ab5eb33383fa31b0e94f4401cdf" name="ga3aa20ab5eb33383fa31b0e94f4401cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aa20ab5eb33383fa31b0e94f4401cdf">&#9670;&nbsp;</a></span>BIT9</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT9&#160;&#160;&#160;(0x00000200)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit 9 mask of an 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11905">11905</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2da6b6038c3e29eb02a23385f7dfe18e" name="ga2da6b6038c3e29eb02a23385f7dfe18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2da6b6038c3e29eb02a23385f7dfe18e">&#9670;&nbsp;</a></span>BYTE0_Msk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTE0_Msk&#160;&#160;&#160;(0x000000FF)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get bit0~bit7 from a 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11930">11930</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga6bdb45c3d1adab74d72eab6116f9581c" name="ga6bdb45c3d1adab74d72eab6116f9581c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdb45c3d1adab74d72eab6116f9581c">&#9670;&nbsp;</a></span>BYTE1_Msk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTE1_Msk&#160;&#160;&#160;(0x0000FF00)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get bit8~bit15 from a 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11931">11931</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga6a926438abfcff696496c60ee5ebd4da" name="ga6a926438abfcff696496c60ee5ebd4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a926438abfcff696496c60ee5ebd4da">&#9670;&nbsp;</a></span>BYTE2_Msk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTE2_Msk&#160;&#160;&#160;(0x00FF0000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get bit16~bit23 from a 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11932">11932</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga26cd8778bf420a922c9cd2bf7c916875" name="ga26cd8778bf420a922c9cd2bf7c916875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26cd8778bf420a922c9cd2bf7c916875">&#9670;&nbsp;</a></span>BYTE3_Msk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BYTE3_Msk&#160;&#160;&#160;(0xFF000000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get bit24~bit31 from a 32 bit integer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11933">11933</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga99496f7308834e8b220f7894efa0b6ab" name="ga99496f7308834e8b220f7894efa0b6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99496f7308834e8b220f7894efa0b6ab">&#9670;&nbsp;</a></span>DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISABLE&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable, define to use in API parameters. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11893">11893</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga514ad415fb6125ba296793df7d1a468a" name="ga514ad415fb6125ba296793df7d1a468a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga514ad415fb6125ba296793df7d1a468a">&#9670;&nbsp;</a></span>ENABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENABLE&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable, define to use in API parameters. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11892">11892</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaa93f0eb578d23995850d61f7d61c55c1" name="gaa93f0eb578d23995850d61f7d61c55c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa93f0eb578d23995850d61f7d61c55c1">&#9670;&nbsp;</a></span>FALSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FALSE&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean false, define to use in API parameters or return value. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11890">11890</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaf4adc89d1a476c51ae52eb700a06fb96" name="gaf4adc89d1a476c51ae52eb700a06fb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4adc89d1a476c51ae52eb700a06fb96">&#9670;&nbsp;</a></span>GET_BYTE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_BYTE0</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">u32Param</td><td>)</td>
          <td>&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga2da6b6038c3e29eb02a23385f7dfe18e">BYTE0_Msk</a>)      )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract Byte 0 (Bit 0~ 7) from parameter u32Param </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11935">11935</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga61fd653ee8852ef7bb04fff1509febc8" name="ga61fd653ee8852ef7bb04fff1509febc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61fd653ee8852ef7bb04fff1509febc8">&#9670;&nbsp;</a></span>GET_BYTE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_BYTE1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">u32Param</td><td>)</td>
          <td>&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6bdb45c3d1adab74d72eab6116f9581c">BYTE1_Msk</a>) &gt;&gt;  8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract Byte 1 (Bit 8~15) from parameter u32Param </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11936">11936</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga35d066854cc83e3823a21f9972fc308f" name="ga35d066854cc83e3823a21f9972fc308f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35d066854cc83e3823a21f9972fc308f">&#9670;&nbsp;</a></span>GET_BYTE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_BYTE2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">u32Param</td><td>)</td>
          <td>&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga6a926438abfcff696496c60ee5ebd4da">BYTE2_Msk</a>) &gt;&gt; 16)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract Byte 2 (Bit 16~23) from parameter u32Param </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11937">11937</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2b580f1b27a79bb2b5924a40c9867ab4" name="ga2b580f1b27a79bb2b5924a40c9867ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b580f1b27a79bb2b5924a40c9867ab4">&#9670;&nbsp;</a></span>GET_BYTE3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_BYTE3</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">u32Param</td><td>)</td>
          <td>&#160;&#160;&#160;((u32Param &amp; <a class="el" href="../../d5/db4/group___mini58__legacy___constants.html#ga26cd8778bf420a922c9cd2bf7c916875">BYTE3_Msk</a>) &gt;&gt; 24)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract Byte 3 (Bit 24~31) from parameter u32Param </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11938">11938</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga070d2ce7b6bb7e5c05602aa8c308d0c4" name="ga070d2ce7b6bb7e5c05602aa8c308d0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070d2ce7b6bb7e5c05602aa8c308d0c4">&#9670;&nbsp;</a></span>NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NULL&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NULL pointer. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11886">11886</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaa8cecfc5c5c054d2875c03e77b7be15d" name="gaa8cecfc5c5c054d2875c03e77b7be15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8cecfc5c5c054d2875c03e77b7be15d">&#9670;&nbsp;</a></span>TRUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TRUE&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean true, define to use in API parameters or return value. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11889">11889</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga5dcf3338bdcd44ad7c3d2c604b8df3a0" name="ga5dcf3338bdcd44ad7c3d2c604b8df3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dcf3338bdcd44ad7c3d2c604b8df3a0">&#9670;&nbsp;</a></span>ADCTCTL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::ADCTCTL0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md198"></a>
ADCTCTL0</h1>
<h2><a class="anchor" id="autotoc_md199"></a>
Offset: 0x68  PWM Trigger Control Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CUTRGEN0   </td><td class="markdownTableBodyLeft">Channel 0 Compare Up Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel0's counter matching CMP0 in up-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CPTRGEN0   </td><td class="markdownTableBodyLeft">Channel 0 Center Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM Trigger ADC Function While channel0's Counter Matching PERIOD0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CDTRGEN0   </td><td class="markdownTableBodyLeft">Channel 0 Compare Down Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel0's counter matching CMP0 in down-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">ZPTRGEN0   </td><td class="markdownTableBodyLeft">Channel 0 Zero Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel0's counter matching 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CUTRGEN1   </td><td class="markdownTableBodyLeft">Channel 1 Compare Up Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel1's counter matching CMP1 in up-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">CPTRGEN1   </td><td class="markdownTableBodyLeft">Channel 1 Center Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel1's counter matching PERIOD1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">CDTRGEN1   </td><td class="markdownTableBodyLeft">Channel 1 Compare Down Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel1's counter matching CMP1 in down-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">ZPTRGEN1   </td><td class="markdownTableBodyLeft">Channel 1 Zero Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function While channel1's Counter Matching 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">CUTRGEN2   </td><td class="markdownTableBodyLeft">Channel 2 Compare Up Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel2's counter matching CMP2 in up-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">CPTRGEN2   </td><td class="markdownTableBodyLeft">Channel 2 Center Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel2's counter matching PERIOD2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">CDTRGEN2   </td><td class="markdownTableBodyLeft">Channel 2 Compare Down Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel2's counter matching CMP2 in down-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">ZPTRGEN2   </td><td class="markdownTableBodyLeft">Channel 2 Zero Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel2's counter matching 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">CUTRGEN3   </td><td class="markdownTableBodyLeft">Channel 3 Compare Up Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel3's counter matching CMP3 in up-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">CPTRGEN3   </td><td class="markdownTableBodyLeft">Channel 3 Center Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel3's counter matching PERIOD3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">CDTRGEN3   </td><td class="markdownTableBodyLeft">Channel 3 Compare Down Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel3's counter matching CMP3 in down-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">ZPTRGEN3   </td><td class="markdownTableBodyLeft">Channel 3 Zero Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel3's counter matching 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged aligned type.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07373">7373</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga16289df68a4d0c4d7e1e5ac164474b57" name="ga16289df68a4d0c4d7e1e5ac164474b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16289df68a4d0c4d7e1e5ac164474b57">&#9670;&nbsp;</a></span>ADCTCTL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::ADCTCTL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md200"></a>
ADCTCTL1</h1>
<h2><a class="anchor" id="autotoc_md201"></a>
Offset: 0x6C  PWM Trigger Control Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CUTRGEN4   </td><td class="markdownTableBodyLeft">Channel 4 Compare Up Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel4's counter matching CMP4 in up-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CPTRGEN4   </td><td class="markdownTableBodyLeft">Channel 4 Center Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel4's counter matching PERIOD4    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CDTRGEN4   </td><td class="markdownTableBodyLeft">Channel 4 Compare Down Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel4's counter matching CMP4 in down-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">ZPTRGEN4   </td><td class="markdownTableBodyLeft">Channel 4 Zero Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel4's counter matching 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CUTRGEN5   </td><td class="markdownTableBodyLeft">Channel 5 Compare Up Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel5's counter matching CMP5 in up-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">CPTRGEN5   </td><td class="markdownTableBodyLeft">Channel 5 Center Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel5's counter matching PERIOD5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is only valid for PWM in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">CDTRGEN5   </td><td class="markdownTableBodyLeft">Channel 5 Compare Down Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel5's counter matching CMP5 in down-count direction    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">ZPTRGEN5   </td><td class="markdownTableBodyLeft">Channel 5 Zero Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable PWM trigger ADC function while channel5's counter matching 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM condition trigger ADC function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM condition trigger ADC function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is valid for both center-aligned type and edged-aligned type.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07427">7427</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga5fef052f7e6f31ba414b6ebd59af1293" name="ga5fef052f7e6f31ba414b6ebd59af1293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fef052f7e6f31ba414b6ebd59af1293">&#9670;&nbsp;</a></span>ADCTSTS0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::ADCTSTS0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md202"></a>
ADCTSTS0</h1>
<h2><a class="anchor" id="autotoc_md203"></a>
Offset: 0x70  PWM Trigger Status Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CUTRGF0   </td><td class="markdownTableBodyLeft">Channel 0 Compare Up Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel0's counter is counting up to CMP0, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CPTRGF0   </td><td class="markdownTableBodyLeft">Channel 0 Center Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel0's counter is counting to PERIOD0, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CDTRGF0   </td><td class="markdownTableBodyLeft">Channel 0 Compare Down Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel0's counter is counting down to CMP0, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">ZPTRGF0   </td><td class="markdownTableBodyLeft">Channel 0 Zero Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel0's counter is counting to zero point, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CUTRGF1   </td><td class="markdownTableBodyLeft">Channel 1 Compare Up Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel1's counter is counting up to CMP1, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">CPTRGF1   </td><td class="markdownTableBodyLeft">Channel 1 Center Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel1's counter is counting to PERIOD1, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">CDTRGF1   </td><td class="markdownTableBodyLeft">Channel 1 Compare Down Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel1's counter is counting down to CMP1, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">ZPTRGF1   </td><td class="markdownTableBodyLeft">Channel 1 Zero Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel1's counter is counting to zero point, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">CUTRGF2   </td><td class="markdownTableBodyLeft">Channel 2 Compare Up Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel2's counter is counting up to CMP2, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">CPTRGF2   </td><td class="markdownTableBodyLeft">Channel 2 Center Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel2's counter is counting to PERIOD2, this bit will be set for trigger ADC. Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">CDTRGF2   </td><td class="markdownTableBodyLeft">Channel 2 Compare Down Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel2's counter is counting down to CMP2, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">ZPTRGF2   </td><td class="markdownTableBodyLeft">Channel 2 Zero Point Trigger ADC Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel2's counter is counting to zero point, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">CUTRGF3   </td><td class="markdownTableBodyLeft">Channel 3 Compare Up Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel3's counter is counting up to CMP3, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">CPTRGF3   </td><td class="markdownTableBodyLeft">Channel 3 Center Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel3's counter is counting to PERIOD3, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">CDTRGF3   </td><td class="markdownTableBodyLeft">Channel 3 Compare Down Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel3's counter is counting down to CMP3, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">ZPTRGF3   </td><td class="markdownTableBodyLeft">Channel 3 Zero Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel3's counter is counting to zero point, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07485">7485</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga40a6a18da1fc9adce379c1635f7723b5" name="ga40a6a18da1fc9adce379c1635f7723b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40a6a18da1fc9adce379c1635f7723b5">&#9670;&nbsp;</a></span>ADCTSTS1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::ADCTSTS1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md204"></a>
ADCTSTS1</h1>
<h2><a class="anchor" id="autotoc_md205"></a>
Offset: 0x74  PWM Trigger Status Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CUTRGF4   </td><td class="markdownTableBodyLeft">Channel 4 Compare Up Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel4's counter is counting up to CMP4, this bit will be set for trigger ADC. Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CPTRGF4   </td><td class="markdownTableBodyLeft">Channel 4 Center Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel4's counter is counting to PERIOD4, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CDTRGF4   </td><td class="markdownTableBodyLeft">Channel 4 Compare Down Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel4's counter is counting down to CMP4, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">ZPTRGF4   </td><td class="markdownTableBodyLeft">Channel 4 Zero Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel4's counter is counting to zero point, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CUTRGF5   </td><td class="markdownTableBodyLeft">Channel 5 Compare Up Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel5's counter is counting up to CMP5, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">CPTRGF5   </td><td class="markdownTableBodyLeft">Channel 5 Center Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel5's counter is counting to PERIOD5, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">CDTRGF5   </td><td class="markdownTableBodyLeft">Channel 5 Compare Down Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel5's counter is counting down to CMP5, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">ZPTRGF5   </td><td class="markdownTableBodyLeft">Channel 5 Zero Point Trigger ADC Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the channel5's counter is counting to zero point, this bit will be set for trigger ADC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07519">7519</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0c4464dd2bbae8e455ec2a8939e0e173" name="ga0c4464dd2bbae8e455ec2a8939e0e173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c4464dd2bbae8e455ec2a8939e0e173">&#9670;&nbsp;</a></span>ADDR0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::ADDR0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md86"></a>
ADDR0</h1>
<h2><a class="anchor" id="autotoc_md87"></a>
Offset: 0x04  I2C Slave Address Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GC   </td><td class="markdownTableBodyLeft">General Call Function Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = General Call Function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = General Call Function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">ADDR   </td><td class="markdownTableBodyLeft">I2C Address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The content of this register is irrelevant when I2C is in Master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode, the seven most significant bits must be loaded with the MCU's own address.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The I2C hardware will react if either of the address is matched.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04603">4603</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga843a249954d4148ab862978604d15ddc" name="ga843a249954d4148ab862978604d15ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga843a249954d4148ab862978604d15ddc">&#9670;&nbsp;</a></span>ADDR1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::ADDR1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md96"></a>
ADDR1</h1>
<h2><a class="anchor" id="autotoc_md97"></a>
Offset: 0x18  I2C Slave Address Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GC   </td><td class="markdownTableBodyLeft">General Call Function Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = General Call Function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = General Call Function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">ADDR   </td><td class="markdownTableBodyLeft">I2C Address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The content of this register is irrelevant when I2C is in Master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode, the seven most significant bits must be loaded with the MCU's own address.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The I2C hardware will react if either of the address is matched.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04688">4688</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gab2bd1ec04483ef731c3af8f0533675c0" name="gab2bd1ec04483ef731c3af8f0533675c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2bd1ec04483ef731c3af8f0533675c0">&#9670;&nbsp;</a></span>ADDR2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::ADDR2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md98"></a>
ADDR2</h1>
<h2><a class="anchor" id="autotoc_md99"></a>
Offset: 0x1C  I2C Slave Address Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GC   </td><td class="markdownTableBodyLeft">General Call Function Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = General Call Function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = General Call Function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">ADDR   </td><td class="markdownTableBodyLeft">I2C Address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The content of this register is irrelevant when I2C is in Master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode, the seven most significant bits must be loaded with the MCU's own address.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The I2C hardware will react if either of the address is matched.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04705">4705</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga08d574a2ddedc447a5858ae7bcfdeb06" name="ga08d574a2ddedc447a5858ae7bcfdeb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08d574a2ddedc447a5858ae7bcfdeb06">&#9670;&nbsp;</a></span>ADDR3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::ADDR3</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md100"></a>
ADDR3</h1>
<h2><a class="anchor" id="autotoc_md101"></a>
Offset: 0x20  I2C Slave Address Register 3</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GC   </td><td class="markdownTableBodyLeft">General Call Function Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = General Call Function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = General Call Function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">ADDR   </td><td class="markdownTableBodyLeft">I2C Address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The content of this register is irrelevant when I2C is in Master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode, the seven most significant bits must be loaded with the MCU's own address.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The I2C hardware will react if either of the address is matched.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04722">4722</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gacd99cf51f40286f80175a8a9f1c0eb75" name="gacd99cf51f40286f80175a8a9f1c0eb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd99cf51f40286f80175a8a9f1c0eb75">&#9670;&nbsp;</a></span>ADDRMSK0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::ADDRMSK0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md102"></a>
ADDRMSK0</h1>
<h2><a class="anchor" id="autotoc_md103"></a>
Offset: 0x24  I2C Slave Address Mask Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">ADDRMSK   </td><td class="markdownTableBodyLeft">I2C Address Mask Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04735">4735</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga7c22b89fc5263ace1981c76d7a18aa11" name="ga7c22b89fc5263ace1981c76d7a18aa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c22b89fc5263ace1981c76d7a18aa11">&#9670;&nbsp;</a></span>ADDRMSK1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::ADDRMSK1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md104"></a>
ADDRMSK1</h1>
<h2><a class="anchor" id="autotoc_md105"></a>
Offset: 0x28  I2C Slave Address Mask Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">ADDRMSK   </td><td class="markdownTableBodyLeft">I2C Address Mask Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04748">4748</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gafe01f1b66375f7c09518dcb6de28e765" name="gafe01f1b66375f7c09518dcb6de28e765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe01f1b66375f7c09518dcb6de28e765">&#9670;&nbsp;</a></span>ADDRMSK2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::ADDRMSK2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md106"></a>
ADDRMSK2</h1>
<h2><a class="anchor" id="autotoc_md107"></a>
Offset: 0x2C  I2C Slave Address Mask Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">ADDRMSK   </td><td class="markdownTableBodyLeft">I2C Address Mask Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04761">4761</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga27aa65a6371d4411cd0e51060cc9b081" name="ga27aa65a6371d4411cd0e51060cc9b081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27aa65a6371d4411cd0e51060cc9b081">&#9670;&nbsp;</a></span>ADDRMSK3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::ADDRMSK3</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md108"></a>
ADDRMSK3</h1>
<h2><a class="anchor" id="autotoc_md109"></a>
Offset: 0x30  I2C Slave Address Mask Register 3</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:1]   </td><td class="markdownTableBodyCenter">ADDRMSK   </td><td class="markdownTableBodyLeft">I2C Address Mask Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04774">4774</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga808b691f73f5988acf98189dc52c2258" name="ga808b691f73f5988acf98189dc52c2258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga808b691f73f5988acf98189dc52c2258">&#9670;&nbsp;</a></span>AHBCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::AHBCLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md30"></a>
AHBCLK</h1>
<h2><a class="anchor" id="autotoc_md31"></a>
Offset: 0x04  AHB Devices Clock Enable Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">ISPCKEN   </td><td class="markdownTableBodyLeft">Flash ISP Controller Clock Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Flash ISP peripheral clock Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Flash ISP peripheral clock Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00889">889</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gad0e91cb2e6d95c030ce2add25e7c39e4" name="gad0e91cb2e6d95c030ce2add25e7c39e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0e91cb2e6d95c030ce2add25e7c39e4">&#9670;&nbsp;</a></span>ALTCTL <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::ALTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md300"></a>
ALTCTL</h1>
<h2><a class="anchor" id="autotoc_md301"></a>
Offset: 0x2C  UART Alternate Control/Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">RS485_NMM   </td><td class="markdownTableBodyLeft">RS-485 Normal Multi-drop Operation Mode (NMM) Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RS-485 Normal Multi-drop Operation Mode (NMM) Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RS-485 Normal Multi-drop Operation Mode (NMM) Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It cannot be active with RS485_AAD operation mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">RS485_AAD   </td><td class="markdownTableBodyLeft">RS-485 Auto Address Detection Operation Mode (AAD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RS-485 Auto Address Detection Operation Mode (AAD) Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RS-485 Auto Address Detection Operation Mode (AAD) Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It cannot be active with RS485_NMM operation mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">RS485_AUD   </td><td class="markdownTableBodyLeft">RS-485 Auto Direction Mode (AUD) Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RS-485 Auto Direction Function Mode (AUD) Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RS-485 Auto Direction Function Mode (AUD) Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It cannot be active with RS485_NMM operation mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">ADDRDEN   </td><td class="markdownTableBodyLeft">RS-485 Address Detection Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is used to enable RS-485 Address Detection mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RS-485 address detection mode Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RS-485 address detection mode Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is used for RS-485 any operation mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31:24]   </td><td class="markdownTableBodyCenter">ADDRMV   </td><td class="markdownTableBodyLeft">Address Match Values    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field contains the RS-485 address match values.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is used for RS-485 auto address detection mode.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11141">11141</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga6162b733283b23b1fc81bdb2ab6a9ef9" name="ga6162b733283b23b1fc81bdb2ab6a9ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6162b733283b23b1fc81bdb2ab6a9ef9">&#9670;&nbsp;</a></span>ALTCTL <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WDT_T::ALTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md306"></a>
ALTCTL</h1>
<h2><a class="anchor" id="autotoc_md307"></a>
Offset: 0x04  WDT Alternative Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">RSTDSEL   </td><td class="markdownTableBodyLeft">WDT Reset Delay Selection (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter by setting RSTCNT (WDT_CTL[0]) to prevent WDT time-out reset happened.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can select a suitable setting of RSTDSEL for different WDT Reset Delay Period.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = WDT Reset Delay Period is 1026 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = WDT Reset Delay Period is 130 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = WDT Reset Delay Period is 18 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = WDT Reset Delay Period is 3 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is write protected. Refer to the SYS_REGLCTL register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This register will be reset to 0 if WDT time-out reset happened.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11473">11473</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gab95b1d5348167498809cbe3d4afa7960" name="gab95b1d5348167498809cbe3d4afa7960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab95b1d5348167498809cbe3d4afa7960">&#9670;&nbsp;</a></span>APBCLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::APBCLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md32"></a>
APBCLK</h1>
<h2><a class="anchor" id="autotoc_md33"></a>
Offset: 0x08  APB Devices Clock Enable Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WDTCKEN   </td><td class="markdownTableBodyLeft">Watchdog Timer Clock Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Watchdog Timer clock Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Watchdog Timer clock Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to the register SYS_REGLCTL at address SYS_BA + 0x10.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TMR0CKEN   </td><td class="markdownTableBodyLeft">Timer0 Clock Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer0 clock Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer0 clock Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TMR1CKEN   </td><td class="markdownTableBodyLeft">Timer1 Clock Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer1 clock Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer1 clock Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">CLKOCKEN   </td><td class="markdownTableBodyLeft">Frequency Divider Output Clock Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CLKO clock Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CLKO clock Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">I2C0CKEN   </td><td class="markdownTableBodyLeft">I2C0 Clock Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C0 clock Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C0 clock Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">I2C1CKEN   </td><td class="markdownTableBodyLeft">I2C1 Clock Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C1 clock Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C1 clock Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">SPICKEN   </td><td class="markdownTableBodyLeft">SPI Clock Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI peripheral clock Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI peripheral clock Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">UART0CKEN   </td><td class="markdownTableBodyLeft">UART0 Clock Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = UART0 clock Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = UART0 clock Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">UART1CKEN   </td><td class="markdownTableBodyLeft">UART1 Clock Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = UART1 clock Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = UART1 clock Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">PWMCH01CKEN   </td><td class="markdownTableBodyLeft">PWM_01 Clock Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM01 clock Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM01 clock Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">PWMCH23CKEN   </td><td class="markdownTableBodyLeft">PWM_23 Clock Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM23 clock Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM23 clock Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">PWMCH45CKEN   </td><td class="markdownTableBodyLeft">PWM_45 Clock Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM45 clock Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM45 clock Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">ADCCKEN   </td><td class="markdownTableBodyLeft">Analog-digital-converter (ADC) Clock Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ADC peripheral clock Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ADC peripheral clock Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">ACMPCKEN   </td><td class="markdownTableBodyLeft">Analog Comparator Clock Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Analog Comparator clock Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Analog Comparator clock Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00943">943</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0ca01dcd16be120667b8ec1b940b2800" name="ga0ca01dcd16be120667b8ec1b940b2800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ca01dcd16be120667b8ec1b940b2800">&#9670;&nbsp;</a></span>BAUD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::BAUD</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md296"></a>
BAUD</h1>
<h2><a class="anchor" id="autotoc_md297"></a>
Offset: 0x24  UART Baud Rate Divisor Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">BRD   </td><td class="markdownTableBodyLeft">Baud Rate Divider    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The field indicates the baud rate divider.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27:24]   </td><td class="markdownTableBodyCenter">EDIVM1   </td><td class="markdownTableBodyLeft">Divider X    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The baud rate divider M = X+1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">BAUDM0   </td><td class="markdownTableBodyLeft">Divider X Equal 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Divider M = X (the equation of M = X+1, but EDIVM1[27:24] must &gt;= 8).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Divider M = 1 (the equation of M = 1, but BRD [15:0] must &gt;= 8).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Refer to section "UART Controller Baud Rate Generator" for more information.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29]   </td><td class="markdownTableBodyCenter">BAUDM1   </td><td class="markdownTableBodyLeft">Divider X Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The BRD = Baud Rate Divider, and the baud rate equation is:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Baud Rate = Clock / [M * (BRD + 2)], The default value of M is 16.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Divider X Disabled (the equation of M = 16).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Divider X Enabled (the equation of M = X+1, but EDIVM1 [27:24] must &gt;= 8).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In IrDA mode, this bit must be disabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11092">11092</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gabcc1733dcd63d84da44ae4c75f6312b2" name="gabcc1733dcd63d84da44ae4c75f6312b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcc1733dcd63d84da44ae4c75f6312b2">&#9670;&nbsp;</a></span>BODCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::BODCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md242"></a>
BODCTL</h1>
<h2><a class="anchor" id="autotoc_md243"></a>
Offset: 0x18  Brown-out Detector Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">BODEN   </td><td class="markdownTableBodyLeft">Brown-out Detector Selection Extension (Initiated &amp; Write-protected Bit)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is set by flash controller user configuration register config0 bit[23].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If config0 bit[23] is set to 1, default value of BODEN is 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If config0 bit[23] is set to 0, default value of BODEN is 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Brown-out detector threshold voltage is selected by the table defined in BODVL.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Brown-out detector threshold voltage is selected by the table defined as below.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BODVL = 00 = Brown-out Detector threshold voltage is 2.2V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BODVL = 01 = Brown-out Detector threshold voltage is 2.7V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BODVL = 10 = Brown-out Detector threshold voltage is 3.7V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">BODVL = 11 = Brown-out Detector threshold voltage is 4.4V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:1]   </td><td class="markdownTableBodyCenter">BODVL   </td><td class="markdownTableBodyLeft">Brown-out Detector Threshold Voltage Selection (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is set by flash controller user configuration register CBOV (CONFIG0[22:21]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Brown-out Detector threshold voltage is 2.7V.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Brown-out Detector threshold voltage is 3.7V.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Brown-out Detector function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">BODRSTEN   </td><td class="markdownTableBodyLeft">Brown-out Reset Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is set by flash controller user configuration register CBORST(CONFIG0[20]) bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Brown-out "INTERRUPT" function Enabled; when the Brown-out Detector function is enable and the detected voltage is lower than the threshold, then assert a signal to interrupt the Cortex-M0 CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Brown-out "RESET" function Enabled; when the Brown-out Detector function is enable and the detected voltage is lower than the threshold then assert a signal to reset the chip.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the BOD_EN is enabled and the interrupt is asserted, the interrupt will be kept till the BOD_EN is set to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The interrupt for CPU can be blocked by disabling the NVIC in CPU for BOD interrupt or disable the interrupt source by disabling the BOD_EN and then re-enabling the BOD_EN function if the BOD function is require.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">BODIF   </td><td class="markdownTableBodyLeft">Brown-out Detector Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BODVL setting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = When Brown-out Detector detects the VDD is dropped through the voltage of BODVL setting or the VDD is raised up through the voltage of BODVL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">BODLPM   </td><td class="markdownTableBodyLeft">Brown-out Detector Low Power Mode (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = BOD operate in normal mode (default).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = BOD Low Power mode Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BODOUT   </td><td class="markdownTableBodyLeft">Brown-out Detector Output Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Brown-out Detector status output is 0, the detected voltage is higher than BODVL setting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Brown-out Detector status output is 1, the detected voltage is lower than BODVL setting.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09634">9634</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2b53247ddc0ba63aa01fa93d73f5e1ed" name="ga2b53247ddc0ba63aa01fa93d73f5e1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b53247ddc0ba63aa01fa93d73f5e1ed">&#9670;&nbsp;</a></span>BRKCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::BRKCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md194"></a>
BRKCTL</h1>
<h2><a class="anchor" id="autotoc_md195"></a>
Offset: 0x60  PWM Fault Brake Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">BRK0EN   </td><td class="markdownTableBodyLeft">Enable BKP0 Pin Trigger Fault Brake Function 0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabling BKP0 pin can trigger brake function 0 (EINT0 or CPO1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabling a falling at BKP0 pin can trigger brake function 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">BRK1EN   </td><td class="markdownTableBodyLeft">Enable BKP1 Pin Trigger Fault Brake Function 1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disabling BKP1 pin can trigger brake function 1 (EINT1 or CPO0).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enabling a falling at BKP1 pin can trigger brake function 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">BRK0SEL   </td><td class="markdownTableBodyLeft">BKP1 Fault Brake Function Source Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = EINT1 as one brake source in BKP1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CPO0 as one brake source in BKP1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">BRK1SEL   </td><td class="markdownTableBodyLeft">BKP0 Fault Brake Function Source Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = EINT0 as one brake source in BKP0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CPO1 as one brake source in BKP0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">BRKSTS   </td><td class="markdownTableBodyLeft">PWM Fault Brake Event Status Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM output initial state when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM output fault brake state when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1 and must be cleared before restarting the PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">BRKACT   </td><td class="markdownTableBodyLeft">PWM Brake Action Type    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM counter stop when brake is asserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM counter keep going when brake is asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">SWBRK   </td><td class="markdownTableBodyLeft">Software Brake    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable PWM Software brake and back to normal PWM function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Assert PWM Brake immediately.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">BKOD0   </td><td class="markdownTableBodyLeft">PWM Brake Output Data Select Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output low when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output high when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">BKOD1   </td><td class="markdownTableBodyLeft">PWM Brake Output Data Select Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output low when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output high when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">BKOD2   </td><td class="markdownTableBodyLeft">PWM Brake Output Data Select Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output low when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output high when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">BKOD3   </td><td class="markdownTableBodyLeft">PWM Brake Output Data Select Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output low when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output high when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">BKOD4   </td><td class="markdownTableBodyLeft">PWM Brake Output Data Select Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output low when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output high when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">BKOD5   </td><td class="markdownTableBodyLeft">PWM Brake Output Data Select Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output low when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output high when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">D6BKOD   </td><td class="markdownTableBodyLeft">Channel 6 Brake Output Data Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 6 output low when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 6 output high when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">D7BKOD   </td><td class="markdownTableBodyLeft">Channel 7 Brake Output Data Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 7 output low when fault brake conditions asserted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 7 output high when fault brake conditions asserted.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07256">7256</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga4dd06cb4142a738d725637c4fa66caff" name="ga4dd06cb4142a738d725637c4fa66caff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd06cb4142a738d725637c4fa66caff">&#9670;&nbsp;</a></span>CAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t TIMER_T::CAP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md272"></a>
CAP</h1>
<h2><a class="anchor" id="autotoc_md273"></a>
Offset: 0x10  Timer0 Capture Data Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]   </td><td class="markdownTableBodyCenter">CAPDAT   </td><td class="markdownTableBodyLeft">Timer Capture Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on TMx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10449">10449</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8a552a9d8396e7a1a9c405359018a349" name="ga8a552a9d8396e7a1a9c405359018a349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a552a9d8396e7a1a9c405359018a349">&#9670;&nbsp;</a></span>CHEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CHEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md10"></a>
CHEN</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
Offset: 0x24  A/D Channel Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CHEN0   </td><td class="markdownTableBodyLeft">Analog Input Channel 0 Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 0 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 0 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If software enables more than one channel, the channel with the smallest number will be selected and the other enabled channels will be ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CHEN1   </td><td class="markdownTableBodyLeft">Analog Input Channel 1 Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 1 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 1 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CHEN2   </td><td class="markdownTableBodyLeft">Analog Input Channel 2 Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 2 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 2 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CHEN3   </td><td class="markdownTableBodyLeft">Analog Input Channel 3 Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 3 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 3 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CHEN4   </td><td class="markdownTableBodyLeft">Analog Input Channel 4 Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 4 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 4 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">CHEN5   </td><td class="markdownTableBodyLeft">Analog Input Channel 5 Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 5 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 5 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">CHEN6   </td><td class="markdownTableBodyLeft">Analog Input Channel 6 Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 6 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 6 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CHEN7   </td><td class="markdownTableBodyLeft">Analog Input Channel 7 Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Channel 7 Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Channel 7 Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CH7SEL   </td><td class="markdownTableBodyLeft">Analog Input Channel 7 Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = External analog input.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Internal band-gap voltage (VBG).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When software selects the band-gap voltage as the analog input source of ADC channel 7, the ADC clock rate needs to be limited to lower than 300 kHz.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00426">426</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gab3f4848afe39a380101231bb0fd35d4d" name="gab3f4848afe39a380101231bb0fd35d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f4848afe39a380101231bb0fd35d4d">&#9670;&nbsp;</a></span>CLKDIV <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKDIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md40"></a>
CLKDIV</h1>
<h2><a class="anchor" id="autotoc_md41"></a>
Offset: 0x18  Clock Divider Number Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">HCLKDIV   </td><td class="markdownTableBodyLeft">HCLK Clock Divide Number From HCLK Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">UARTDIV   </td><td class="markdownTableBodyLeft">UART Clock Divide Number From UART Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">UART clock frequency = (UART clock source frequency) / (UARTDIV + 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">ADCDIV   </td><td class="markdownTableBodyLeft">ADC Peripheral Clock Divide Number From ADC Peripheral Clock Source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ADC peripheral clock frequency = (ADC peripheral clock source frequency) / (ADCDIV + 1).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01088">1088</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga42ae778f266a41953e0d625b77c8f76f" name="ga42ae778f266a41953e0d625b77c8f76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ae778f266a41953e0d625b77c8f76f">&#9670;&nbsp;</a></span>CLKDIV <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::CLKDIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md92"></a>
CLKDIV</h1>
<h2><a class="anchor" id="autotoc_md93"></a>
Offset: 0x10  I2C Clock Divided Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">DIVIDER   </td><td class="markdownTableBodyLeft">I2C Clock Divided Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The I2C clock rate bits: Data Baud Rate of I2C = (system clock) / (4 * (I2C_CLKDIV+1)).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The minimum value of I2C_CLKDIV is 4.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04649">4649</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gabc4c6580a6e99fbd6faf507f730c2ec3" name="gabc4c6580a6e99fbd6faf507f730c2ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc4c6580a6e99fbd6faf507f730c2ec3">&#9670;&nbsp;</a></span>CLKDIV <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CLKDIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md160"></a>
CLKDIV</h1>
<h2><a class="anchor" id="autotoc_md161"></a>
Offset: 0x04  PWM Clock Select Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">CLKDIV0   </td><td class="markdownTableBodyLeft">Counter 0 Clock Divider Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock input / (CLKPSC01/2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Clock input / (CLKPSC01/4).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock input / (CLKPSC01/8).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock input / (CLKPSC01/16).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = Clock input / CLKPSC01.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Clock input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">CLKDIV1   </td><td class="markdownTableBodyLeft">Counter 1 Clock Divider Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock input / (CLKPSC01/2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Clock input / (CLKPSC01/4).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock input / (CLKPSC01/8).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock input / (CLKPSC01/16).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = Clock input / CLKPSC01.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Clock input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">CLKDIV2   </td><td class="markdownTableBodyLeft">Counter 2 Clock Divider Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock input / (CLKPSC23/2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Clock input / (CLKPSC23/4).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock input / (CLKPSC23/8).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock input / (CLKPSC23/16).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = Clock input / CLKPSC23.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Clock input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:12]   </td><td class="markdownTableBodyCenter">CLKDIV3   </td><td class="markdownTableBodyLeft">Counter 3 Clock Divider Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock input / (CLKPSC23/2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Clock input / (CLKPSC23/4).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock input / (CLKPSC23/8).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock input / (CLKPSC23/16).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = Clock input / CLKPSC23.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Clock input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18:16]   </td><td class="markdownTableBodyCenter">CLKDIV4   </td><td class="markdownTableBodyLeft">Counter 4 Clock Divider Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock input / (CLKPSC45/2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Clock input / (CLKPSC45/4).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock input / (CLKPSC45/8).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock input / (CLKPSC45/16).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = Clock input / CLKPSC45.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Clock input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22:20]   </td><td class="markdownTableBodyCenter">CLKDIV5   </td><td class="markdownTableBodyLeft">Counter 5 Clock Divider Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Select clock input for PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock input / (CLKPSC45/2).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Clock input / (CLKPSC45/4).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock input / (CLKPSC45/8).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock input / (CLKPSC45/16).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = Clock input / CLKPSC45.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Clock input.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05460">5460</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga6ea1e761f8c180884bc051c73db22e13" name="ga6ea1e761f8c180884bc051c73db22e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea1e761f8c180884bc051c73db22e13">&#9670;&nbsp;</a></span>CLKDIV <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CLKDIV</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md220"></a>
CLKDIV</h1>
<h2><a class="anchor" id="autotoc_md221"></a>
Offset: 0x04  SPI Clock Divider Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">DIVIDER   </td><td class="markdownTableBodyLeft">Clock Divider Register (Master Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The value in this field is the frequency divider to determine the SPI peripheral clock frequency fspi, and the SPI master's bus clock frequency on the SPI_CLK output pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The frequency is obtained according to the following equation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit of DIVMOD, SPI_SLVCTL[31], is set to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">else if DIVMOD is set to 1,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">where    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">is the SPI peripheral clock source which is defined in the CLK_CLKSEL1 register.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09078">9078</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga9d505afae945a248261c38c266a4deab" name="ga9d505afae945a248261c38c266a4deab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d505afae945a248261c38c266a4deab">&#9670;&nbsp;</a></span>CLKOCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKOCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md46"></a>
CLKOCTL</h1>
<h2><a class="anchor" id="autotoc_md47"></a>
Offset: 0x24  Frequency Divider Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">FREQSEL   </td><td class="markdownTableBodyLeft">Divider Output Frequency Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The formula of output frequency is    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Fout = Fin/2(N+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Fin is the input clock frequency.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Fout is the frequency of divider output clock.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">N is the 4-bit value of FREQSEL(CLK_CLKOCTL[3:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CLKOEN   </td><td class="markdownTableBodyLeft">Frequency Divider Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Frequency Divider Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Frequency Divider Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">DIV1EN   </td><td class="markdownTableBodyLeft">Frequency Divider One Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Divider output frequency is depended on FREQSEL value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Divider output frequency is the same as input clock frequency.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01166">1166</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gac2c901e81cfb5c40d77de799ea903246" name="gac2c901e81cfb5c40d77de799ea903246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2c901e81cfb5c40d77de799ea903246">&#9670;&nbsp;</a></span>CLKPSC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CLKPSC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md158"></a>
CLKPSC</h1>
<h2><a class="anchor" id="autotoc_md159"></a>
Offset: 0x00  PWM Clock Pre-scale Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">CLKPSC01   </td><td class="markdownTableBodyLeft">Clock Prescaler 0 For PWM Counter 0 And 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Clock input is divided by (CLKPSC01 + 1) before it is fed to the corresponding PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CLKPSC01 = 0, the clock prescaler 0 output clock will be stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So the corresponding PWM counter will also be stopped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:8]   </td><td class="markdownTableBodyCenter">CLKPSC23   </td><td class="markdownTableBodyLeft">Clock Prescaler 2 For PWM Counter 2 And 3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Clock input is divided by (CLKPSC23 + 1) before it is fed to the corresponding PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CLKPSC23 = 0, the clock prescaler 2 output clock will be stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So the corresponding PWM counter will also be stopped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">CLKPSC45   </td><td class="markdownTableBodyLeft">Clock Prescaler 4 For PWM Counter 4 And 5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Clock input is divided by (CLKPSC45 + 1) before it is fed to the corresponding PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CLKPSC45 = 0, the clock prescaler 4 output clock will be stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So the corresponding PWM counter will also be stopped.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05402">5402</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gae5d0e2a48518b0d44641f594a763b619" name="gae5d0e2a48518b0d44641f594a763b619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d0e2a48518b0d44641f594a763b619">&#9670;&nbsp;</a></span>CLKSEL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKSEL0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md36"></a>
CLKSEL0</h1>
<h2><a class="anchor" id="autotoc_md37"></a>
Offset: 0x10  Clock Source Select Control Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:0]   </td><td class="markdownTableBodyCenter">HCLKSEL   </td><td class="markdownTableBodyLeft">HCLK Clock Source Selection (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock source is from HXT or LXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock source is from PLL.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock source is from LIRC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = Clock source is from HIRC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Before clock switching, the related clock sources (both pre-select and new-select) must be turn-on and stable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: These bits are protected bit, and programming them needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to the register SYS_REGLCTL at address SYS_BA + 0x10.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: To set CLK_PWRCTL[1:0] to select HXT or LXT crystal clock.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:3]   </td><td class="markdownTableBodyCenter">STCLKSEL   </td><td class="markdownTableBodyLeft">Cortex-M0 SysTick Clock Source Selection (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CLKSRC (SYST_CSR[2]) = 1, SysTick clock source is from HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CLKSRC (SYST_CSR[2]) = 0, SysTick clock source is defined by below settings.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock source is from HXT or LXT.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock source is from HXT/2 or LXT/2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock source is from HCLK/2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = Clock source is from HIRC/2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: These bits are protected bit, and programming them needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to the register SYS_REGLCTL at address SYS_BA + 0x10.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If the SysTick clock source is not from HCLK (i.e.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CLKSRC(SYST_CSR[2]) = 0), SysTick clock source must less than or equal to HCLK/.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01008">1008</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga9cad9e775d46b22aad65c5caa3ba9cbf" name="ga9cad9e775d46b22aad65c5caa3ba9cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cad9e775d46b22aad65c5caa3ba9cbf">&#9670;&nbsp;</a></span>CLKSEL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKSEL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md38"></a>
CLKSEL1</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
Offset: 0x14  Clock Source Select Control Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">WDTSEL   </td><td class="markdownTableBodyLeft">WDT CLK Clock Source Selection (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Clock source is from HXT or LXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Clock source is from HCLK/2048 clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Clock source is from LIRC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: These bits are the protected bit, and programming them needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to the register SYS_REGLCTL at address SYS_BA + 0x10.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">ADCSEL   </td><td class="markdownTableBodyLeft">ADC Peripheral Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Clock source is from HXT or LXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Clock source is from PLL.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Clock source is from HCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Clock source is from HIRC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">SPISEL   </td><td class="markdownTableBodyLeft">SPI Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Clock source is from HXT or LXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Clock source is from HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Clock source is from PLL.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">TMR0SEL   </td><td class="markdownTableBodyLeft">TIMER0 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock source is from HXT or LXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Clock source is from LIRC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock source is from HCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock source is from external trigger.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = Clock source is from HIRC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14:12]   </td><td class="markdownTableBodyCenter">TMR1SEL   </td><td class="markdownTableBodyLeft">TIMER1 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = Clock source is from HXT or LXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = Clock source is from LIRC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = Clock source is from HCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = Clock source is from external trigger.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = Clock source is from HIRC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25:24]   </td><td class="markdownTableBodyCenter">UARTSEL   </td><td class="markdownTableBodyLeft">UART Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Clock source is from HXT or LXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Clock source is from PLL.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Clock source is from HIRC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Clock source is from HIRC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:28]   </td><td class="markdownTableBodyCenter">PWMCH01SEL   </td><td class="markdownTableBodyLeft">PWM0 And PWM1 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM0 and PWM1 use the same peripheral clock source. Both of them use the same prescaler.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Clock source is from HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:30]   </td><td class="markdownTableBodyCenter">PWMCH23SEL   </td><td class="markdownTableBodyLeft">PWM2 And PWM3 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM2 and PWM3 use the same peripheral clock source; Both of them use the same prescaler.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Clock source is from HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01072">1072</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga505ef1b8c8d11745b09418636c576b6f" name="ga505ef1b8c8d11745b09418636c576b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga505ef1b8c8d11745b09418636c576b6f">&#9670;&nbsp;</a></span>CLKSEL2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::CLKSEL2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md42"></a>
CLKSEL2</h1>
<h2><a class="anchor" id="autotoc_md43"></a>
Offset: 0x1C  Clock Source Select Control Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">CLKOSEL   </td><td class="markdownTableBodyLeft">Clock Divider Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Clock source is from HXT or LXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Clock source is from LIRC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Clock source is from HCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Clock source is from HIRC.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">PWMCH45SEL   </td><td class="markdownTableBodyLeft">PWM4 And PWM5 Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM4 and PWM5 use the same peripheral clock source; Both of them use the same prescaler.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Clock source is from HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17:16]   </td><td class="markdownTableBodyCenter">WWDTSEL   </td><td class="markdownTableBodyLeft">Window Watchdog Timer Clock Source Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Clock source from HCLK/2048 clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01115">1115</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2816828e99d2aec59a5484bfb0d02624" name="ga2816828e99d2aec59a5484bfb0d02624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2816828e99d2aec59a5484bfb0d02624">&#9670;&nbsp;</a></span>CMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::CMP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md266"></a>
CMP</h1>
<h2><a class="anchor" id="autotoc_md267"></a>
Offset: 0x04  Timer0 Compare Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]   </td><td class="markdownTableBodyCenter">CMPDAT   </td><td class="markdownTableBodyLeft">Timer Compared Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDAT is a 24-bit compared value register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to .    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into the CMPDAT fiel.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10403">10403</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaf4756c188834873a45d077b6ca79f37c" name="gaf4756c188834873a45d077b6ca79f37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4756c188834873a45d077b6ca79f37c">&#9670;&nbsp;</a></span>CMP0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CMP0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md12"></a>
CMP0</h1>
<h2><a class="anchor" id="autotoc_md13"></a>
Offset: 0x28  A/D Compare Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ADCMPEN   </td><td class="markdownTableBodyLeft">A/D Compare Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set 1 to this bit to enable comparing CMPDAT (ADC_CMPx[25:16]) with specified channel conversion results when converted data is loaded into the ADC_DAT register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Compare function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Compare function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ADCMPIE   </td><td class="markdownTableBodyLeft">A/D Compare Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMCNT, ADCMPIE bit will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Compare function interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Compare function interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CMPCOND   </td><td class="markdownTableBodyLeft">Compare Condition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Set the compare condition as that when a 10-bit A/D conversion result is less than the 10-bit CMPDAT (ADC_CMPx[25:16]), the internal match counter will increase one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Set the compare condition as that when a 10-bit A/D conversion result is greater or equal to the 10-bit CMPDAT (ADC_CMPx[25:16]), the internal match counter will increase one.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the internal counter reaches the value to (CMPMCNT+1), the ADCMPFx bit will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:3]   </td><td class="markdownTableBodyCenter">CMPCH   </td><td class="markdownTableBodyLeft">Compare Channel Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this field to select which channel's result to be compared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Valid setting of this field is channel 0~7.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">CMPMCNT   </td><td class="markdownTableBodyLeft">Compare Match Count    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the internal counter reaches the value to (CMPMCNT+1), the ADCMPFx bit will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25:16]   </td><td class="markdownTableBodyCenter">CMPDAT   </td><td class="markdownTableBodyLeft">Comparison Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The 10-bit data is used to compare with conversion result of specified channel.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00456">456</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga92c0061430e3d538b92bd0cd493065bf" name="ga92c0061430e3d538b92bd0cd493065bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92c0061430e3d538b92bd0cd493065bf">&#9670;&nbsp;</a></span>CMP1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CMP1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md14"></a>
CMP1</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
Offset: 0x2C  A/D Compare Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ADCMPEN   </td><td class="markdownTableBodyLeft">A/D Compare Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set 1 to this bit to enable comparing CMPDAT (ADC_CMPx[25:16]) with specified channel conversion results when converted data is loaded into the ADC_DAT register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Compare function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Compare function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ADCMPIE   </td><td class="markdownTableBodyLeft">A/D Compare Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMCNT, ADCMPIE bit will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Compare function interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Compare function interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CMPCOND   </td><td class="markdownTableBodyLeft">Compare Condition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Set the compare condition as that when a 10-bit A/D conversion result is less than the 10-bit CMPDAT (ADC_CMPx[25:16]), the internal match counter will increase one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Set the compare condition as that when a 10-bit A/D conversion result is greater or equal to the 10-bit CMPDAT (ADC_CMPx[25:16]), the internal match counter will increase one.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the internal counter reaches the value to (CMPMCNT+1), the ADCMPFx bit will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:3]   </td><td class="markdownTableBodyCenter">CMPCH   </td><td class="markdownTableBodyLeft">Compare Channel Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this field to select which channel's result to be compared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Valid setting of this field is channel 0~7.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">CMPMCNT   </td><td class="markdownTableBodyLeft">Compare Match Count    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the internal counter reaches the value to (CMPMCNT+1), the ADCMPFx bit will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25:16]   </td><td class="markdownTableBodyCenter">CMPDAT   </td><td class="markdownTableBodyLeft">Comparison Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The 10-bit data is used to compare with conversion result of specified channel.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00486">486</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gab7c05a16118a0d1c2d76c81856e16802" name="gab7c05a16118a0d1c2d76c81856e16802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c05a16118a0d1c2d76c81856e16802">&#9670;&nbsp;</a></span>CMPDAT0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CMPDAT0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md176"></a>
CMPDAT0</h1>
<h2><a class="anchor" id="autotoc_md177"></a>
Offset: 0x24  PWM Comparator Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP0   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP1   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP2   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP3   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP4   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP5   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD0   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD1   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD2   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD3   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD4   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD5   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l06333">6333</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga213a53325a0263f913f88f22fb5a2e5b" name="ga213a53325a0263f913f88f22fb5a2e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga213a53325a0263f913f88f22fb5a2e5b">&#9670;&nbsp;</a></span>CMPDAT1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CMPDAT1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md178"></a>
CMPDAT1</h1>
<h2><a class="anchor" id="autotoc_md179"></a>
Offset: 0x28  PWM Comparator Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP0   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP1   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP2   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP3   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP4   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP5   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD0   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD1   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD2   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD3   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD4   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD5   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l06463">6463</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8a75a4f2a04ab1ecbc986d8913dc9c1e" name="ga8a75a4f2a04ab1ecbc986d8913dc9c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a75a4f2a04ab1ecbc986d8913dc9c1e">&#9670;&nbsp;</a></span>CMPDAT2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CMPDAT2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md180"></a>
CMPDAT2</h1>
<h2><a class="anchor" id="autotoc_md181"></a>
Offset: 0x2C  PWM Comparator Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP0   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP1   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP2   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP3   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP4   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP5   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD0   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD1   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD2   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD3   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD4   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD5   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l06593">6593</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga01ccf8537af74bc24277096f3e8f5eae" name="ga01ccf8537af74bc24277096f3e8f5eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ccf8537af74bc24277096f3e8f5eae">&#9670;&nbsp;</a></span>CMPDAT3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CMPDAT3</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md182"></a>
CMPDAT3</h1>
<h2><a class="anchor" id="autotoc_md183"></a>
Offset: 0x30  PWM Comparator Register 3</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP0   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP1   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP2   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP3   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP4   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP5   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD0   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD1   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD2   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD3   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD4   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD5   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l06723">6723</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gab0ffc95951bedea134bb5b3506e8ed5c" name="gab0ffc95951bedea134bb5b3506e8ed5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0ffc95951bedea134bb5b3506e8ed5c">&#9670;&nbsp;</a></span>CMPDAT4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CMPDAT4</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md184"></a>
CMPDAT4</h1>
<h2><a class="anchor" id="autotoc_md185"></a>
Offset: 0x34  PWM Comparator Register 4</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP0   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP1   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP2   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP3   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP4   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP5   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD0   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD1   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD2   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD3   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD4   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD5   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l06853">6853</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga76d422a9662172c36a3b468165496a1c" name="ga76d422a9662172c36a3b468165496a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76d422a9662172c36a3b468165496a1c">&#9670;&nbsp;</a></span>CMPDAT5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CMPDAT5</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md186"></a>
CMPDAT5</h1>
<h2><a class="anchor" id="autotoc_md187"></a>
Offset: 0x38  PWM Comparator Register 5</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP0   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP1   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP2   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP3   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP4   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">CMP5   </td><td class="markdownTableBodyLeft">PWM Comparator Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMP determines the PWM duty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/(PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to CMPn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD0   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD1   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD2   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD3   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD4   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:16]   </td><td class="markdownTableBodyCenter">CMPD5   </td><td class="markdownTableBodyLeft">PWM Comparator Register For Down Counter In Asymmetric Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: up counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPDn &gt;= PERIODn: down counter PWM output is always low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others: PWM output is always high.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l06983">6983</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaf2463dd197cada9380f6dcb2fff23f2b" name="gaf2463dd197cada9380f6dcb2fff23f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2463dd197cada9380f6dcb2fff23f2b">&#9670;&nbsp;</a></span>CNT <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t TIMER_T::CNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md270"></a>
CNT</h1>
<h2><a class="anchor" id="autotoc_md271"></a>
Offset: 0x0C  Timer0 Data Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:0]   </td><td class="markdownTableBodyCenter">CNT   </td><td class="markdownTableBodyLeft">Timer Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field can be reflected the internal 24-bit timer counter value or external event input counter value from TMx (x=0~1) pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If EXTCNTEN (TIMERx_CTL[24]) is 0, user can read CNT value for getting current 24- bit counter value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If EXTCNTEN (TIMERx_CTL[24]) is 1, user can read CNT value for getting current 24- bit event input counter value.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10437">10437</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gacaff670a5cd05add2f25ebe61a99727a" name="gacaff670a5cd05add2f25ebe61a99727a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaff670a5cd05add2f25ebe61a99727a">&#9670;&nbsp;</a></span>CNT <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t WWDT_T::CNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md314"></a>
CNT</h1>
<h2><a class="anchor" id="autotoc_md315"></a>
Offset: 0x0C  WWDT Counter Value Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">CNTDAT   </td><td class="markdownTableBodyLeft">WWDT Counter Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CNTDAT will be updated continuously to monitor 6-bit WWDT down counter value.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11617">11617</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga09268af0bfe8e5340cf8f297724a9f27" name="ga09268af0bfe8e5340cf8f297724a9f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09268af0bfe8e5340cf8f297724a9f27">&#9670;&nbsp;</a></span>CON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t INTR_T::CON</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md154"></a>
CON</h1>
<h2><a class="anchor" id="autotoc_md155"></a>
Offset: 0x80  NMI Source Interrupt Select Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4:0]   </td><td class="markdownTableBodyCenter">NMI_SEL   </td><td class="markdownTableBodyLeft">NMI Interrupt Source Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMI_SEL.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">NMI_SEL_EN   </td><td class="markdownTableBodyLeft">NMI Interrupt Enable Bit (Write Protected)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = NMI interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = NMI interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to the register SYS_REGLCTL at address SYS_BA+0x10.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05262">5262</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga1c920595c6586bec644d46e2c1350b1c" name="ga1c920595c6586bec644d46e2c1350b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c920595c6586bec644d46e2c1350b1c">&#9670;&nbsp;</a></span>CTL <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ACMP_T::CTL[2]</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md0"></a>
CTL0, 1</h1>
<h2><a class="anchor" id="autotoc_md1"></a>
Offset: 0x00, 0x04  Analog Comparator 0, 1 Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ACMPEN   </td><td class="markdownTableBodyLeft">Analog Comparator x Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Analog Comparator x Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Analog Comparator x Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Analog comparator output needs to wait 2 us stable time after this bit is set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ACMPIE   </td><td class="markdownTableBodyLeft">Analog Comparator x Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Interrupt function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Interrupt function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">HYSSEL   </td><td class="markdownTableBodyLeft">Analog Comparator x Hysteresis Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Hysteresis function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Hysteresis function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">NEGSEL   </td><td class="markdownTableBodyLeft">Analog Comparator x Negative Input Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The source of the negative comparator input is from CPNx pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The source of the negative comparator input is from internal band-gap voltage or comparator reference voltage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">RTRGEN   </td><td class="markdownTableBodyLeft">Analog Comparator x Rising Edge Trigger Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Analog comparator rising edge trigger PWM or Timer enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Analog comparator rising edge trigger disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The bit is only effective while analog comparator x triggers PWM or Timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">FTRGEN   </td><td class="markdownTableBodyLeft">Analog Comparator x Falling Edge Trigger Enable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Analog comparator falling edge trigger PWM or Timer enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Analog comparator falling edge trigger disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The bit is only effective while analog comparator x triggers PWM or Timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:20]   </td><td class="markdownTableBodyCenter">FILTSEL   </td><td class="markdownTableBodyLeft">Comparator Output Filter Count Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = Filter function is Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = ACMP0 output is sampled 1 consecutive PCLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = ACMP0 output is sampled 2 consecutive PCLKs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = ACMP0 output is sampled 4 consecutive PCLKs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = ACMP0 output is sampled 8 consecutive PCLKs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = ACMP0 output is sampled 16 consecutive PCLKs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = ACMP0 output is sampled 32 consecutive PCLKs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = ACMP0 output is sampled 64 consecutive PCLKs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = ACMP0 output is sampled 128 consecutive PCLKs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = ACMP0 output is sampled 256 consecutive PCLKs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1010 = ACMP0 output is sampled 512 consecutive PCLKs.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30:29]   </td><td class="markdownTableBodyCenter">POSSEL   </td><td class="markdownTableBodyLeft">Analog Comparator Positive Input Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = ACMP0_Px is from ACMPx_P0 pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = ACMP0_Px is from ACMPx_P1 pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = ACMP0_Px is from ACMPx_P2 pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = ACMP0_Px is from ACMPx_P3 pin.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00213">213</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaa8a989c17bfe13704d599376218c9d93" name="gaa8a989c17bfe13704d599376218c9d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8a989c17bfe13704d599376218c9d93">&#9670;&nbsp;</a></span>CTL <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md8"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Offset: 0x20  A/D Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ADCEN   </td><td class="markdownTableBodyLeft">A/D Converter Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = A/D Converter Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = A/D Converter Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Before starting A/D conversion function, this bit should be set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Clear it to 0 to disable A/D converter analog circuit to save power consumption.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ADCIEN   </td><td class="markdownTableBodyLeft">A/D Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">A/D conversion end interrupt request is generated if ADCIEN bit is set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = A/D interrupt function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = A/D interrupt function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">HWTRGSEL   </td><td class="markdownTableBodyLeft">Hardware Trigger Source Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = A/D conversion is started by external STADC pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = A/D conversion is started by PWM trigger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software should disable TRGEN and SWTRG before change TRGS.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">HWTRGCOND   </td><td class="markdownTableBodyLeft">Hardware External Trigger Condition    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit decides whether the external pin STADC trigger event is falling or raising edge.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The signal must be kept at stable state at least 4 PCLKs at high and low state for edge trigge.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Falling edge.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Raising edge.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">HWTRGEN   </td><td class="markdownTableBodyLeft">Hardware External Trigger Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Enable or disable triggering of A/D conversion by external STADC pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If external trigger is enabled, the SWTRG bit can be set to 1 by the selected hardware trigger sourc.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0= External trigger Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1= External trigger Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">SWTRG   </td><td class="markdownTableBodyLeft">Software Trigger A/D Conversion Start    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SWTRG bit can be set to 1 from two sources: software and external pin STADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SWTRG will be cleared to 0 by hardware automatically after conversion complet.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Conversion stopped and A/D converter entered idle state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Conversion start.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00387">387</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gabeaddca0794806b689834bdbeeaca072" name="gabeaddca0794806b689834bdbeeaca072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeaddca0794806b689834bdbeeaca072">&#9670;&nbsp;</a></span>CTL <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md84"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md85"></a>
Offset: 0x00  I2C Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">AA   </td><td class="markdownTableBodyLeft">Assert Acknowledge Control Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When AA=1 is prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">SI   </td><td class="markdownTableBodyLeft">I2C Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When a new I2C state is present in the I2C_STATUS register, the SI flag is set by hardware, and if bit INTEN (I2C_CTL[7]) is set, the I2C interrupt is requested.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SI must be cleared by software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be cleared by software writing '1'.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">STO   </td><td class="markdownTableBodyLeft">I2C STOP Control Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Slave mode, setting STO resets I2C hardware to the defined "not addressed" Slave mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This means it is NO LONGER in the Slave receiver mode to receive data from the master transmit device.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">STA   </td><td class="markdownTableBodyLeft">I2C START Control Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set STA to logic 1 to enter Master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">I2C hardware sends a START or repeats the START condition to bus when the bus is free.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">I2CEN   </td><td class="markdownTableBodyLeft">I2C Controller Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C Controller Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C Controller Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set to enable I2C serial function controller.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When I2CEN=1 the I2C serial function enables.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The function of multi-function pin must be set to I2C firs.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">INTEN   </td><td class="markdownTableBodyLeft">Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C interrupt Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04586">4586</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0a5218f3d6ce38a982289ba890e94ebc" name="ga0a5218f3d6ce38a982289ba890e94ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a5218f3d6ce38a982289ba890e94ebc">&#9670;&nbsp;</a></span>CTL <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md162"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md163"></a>
Offset: 0x08  PWM Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CNTEN0   </td><td class="markdownTableBodyLeft">PWM Counter 0 Enable Start Run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding PWM counter running Stopped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding PWM counter start run Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">DBGTRIOFF   </td><td class="markdownTableBodyLeft">Disable PWM Output Tri-state Under Debug Mode (Available In DEBUG Mode Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Safe mode: The counter is frozen and PWM outputs are shut down Safe state for the inverter.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The counter can still be re-started from where it stop.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Normal mode: The counter continues to operate normally May be dangerous in some cases since a constant duty cycle is applied to the inverter (no more interrupts serviced).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">PINV0   </td><td class="markdownTableBodyLeft">PWM0_CH0 Output Inverter Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH0 output inverter Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH0 output inverter Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CNTMODE0   </td><td class="markdownTableBodyLeft">PWM Counter 0 Auto-reload/One-shot Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-shot mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-reload mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause PERIOD0 and CMP0 cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CNTEN1   </td><td class="markdownTableBodyLeft">PWM Counter 1 Enable/Disable Start Run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding PWM counter running Stopped.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding PWM counter start run Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">HCUPDT   </td><td class="markdownTableBodyLeft">Half Cycle Update Enable for Center-aligned Type    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Disable half cycle update PERIOD &amp; CMP.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Enable half cycle update PERIOD &amp; CMP.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">PINV1   </td><td class="markdownTableBodyLeft">PWM0_CH1 Output Inverter Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH1 output inverter Disable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH1 output inverter Enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CNTMODE1   </td><td class="markdownTableBodyLeft">PWM Counter 1 Auto-reload/One-shot Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-shot mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-reload mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause PERIOD1 and CMP1 cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CNTEN2   </td><td class="markdownTableBodyLeft">PWM Counter 2 Enable Start Run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding PWM counter running Stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding PWM counter start run Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">PINV2   </td><td class="markdownTableBodyLeft">PWM0_CH2 Output Inverter Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH2 output inverter Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH2 output inverter Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">CNTMODE2   </td><td class="markdownTableBodyLeft">PWM Counter 2 Auto-reload/One-shot Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-shot mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-reload mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause PERIOD2 and CMP2 cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">CNTEN3   </td><td class="markdownTableBodyLeft">PWM Counter 3 Enable Start Run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding PWM counter running Stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding PWM counter start run Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">PINV3   </td><td class="markdownTableBodyLeft">PWM0_CH 3 Output Inverter Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH3 output inverter Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH3 output inverter Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">CNTMODE3   </td><td class="markdownTableBodyLeft">PWM Counter 3 Auto-reload/One-shot Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-shot mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-reload mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause PERIOD3 and CMP3 cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">CNTEN4   </td><td class="markdownTableBodyLeft">PWM Counter 4 Enable Start Run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding PWM counter running Stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding PWM counter start run Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">PINV4   </td><td class="markdownTableBodyLeft">PWM0_CH4 Output Inverter Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH4 output inverter Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH4 output inverter Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">CNTMODE4   </td><td class="markdownTableBodyLeft">PWM Counter 4 Auto-reload/One-shot Mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-shot mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-reload mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause PERIOD4 and CMP4 cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">CNTEN5   </td><td class="markdownTableBodyLeft">PWM Counter 5 Enable Start Run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding PWM counter running Stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding PWM counter start run Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">ASYMEN   </td><td class="markdownTableBodyLeft">Asymmetric Mode In Center-aligned Type    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Symmetric mode in center-aligned type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Asymmetric mode in center-aligned type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">PINV5   </td><td class="markdownTableBodyLeft">PWM0_CH5 Output Inverter Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH5 output inverter Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH5 output inverter Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">CNTMODE5   </td><td class="markdownTableBodyLeft">PWM Counter 5 Auto-reload/One-shot Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One-shot mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Auto-reload mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If there is a rising transition at this bit, it will cause PERIOD5 and CMP5 cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">DTCNT01   </td><td class="markdownTableBodyLeft">Dead-time 0 Counter Enable Bit (PWM0_CH0 And PWM0_CH1 Pair For PWMA Group)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Dead-time 0 generator Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Dead-time 0 generator Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the dead-time generator is enabled, the pair of PWM0_CH0 and PWM0_CH1 becomes a complementary pair for PWMA group.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">DTCNT23   </td><td class="markdownTableBodyLeft">Dead-time 2 Counter Enable Bit (PWM0_CH2 And PWM0_CH3 Pair For PWMB Group)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Dead-time 2 generator Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Dead-time 2 generator Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the dead-time generator is enabled, the pair of PWM0_CH2 and PWM0_CH3 becomes a complementary pair for PWMB group.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">DTCNT45   </td><td class="markdownTableBodyLeft">Dead-time 4 Counter Enable Bit (PWM0_CH4 And PWM0_CH5 Pair For PWMC Group)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Dead-time 4 generator Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Dead-time 4 generator Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the dead-time generator is enabled, the pair of PWM0_CH4 and PWM0_CH5 becomes a complementary pair for PWMC group.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">CNTCLR   </td><td class="markdownTableBodyLeft">Clear PWM Counter Control Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Do not clear PWM counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = All 16-bit PWM counters cleared to 0x0000.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is automatically cleared by hardware.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:28]   </td><td class="markdownTableBodyCenter">MODE   </td><td class="markdownTableBodyLeft">PWM Operating Mode Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Independent mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Complementary mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Synchronized mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">GROUPEN   </td><td class="markdownTableBodyLeft">Group Function Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The signals timing of all PWM channels are independent.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Unify the signals timing of PWM0_CH0, PWM0_CH2 and PWM0_CH4 in the same phase which is controlled by PWM0_CH0 and also unify the signals timing of PWM0_CH1, PWM0_CH3 and PWM0_CH5 in the same phase which is controlled by PWM0_CH1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">CNTTYPE   </td><td class="markdownTableBodyLeft">PWM Counter-aligned Type Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge-aligned type.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Center-aligned type.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05567">5567</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga069fd6acdea1842f24bba35267ff3ea5" name="ga069fd6acdea1842f24bba35267ff3ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga069fd6acdea1842f24bba35267ff3ea5">&#9670;&nbsp;</a></span>CTL <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md218"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md219"></a>
Offset: 0x00  SPI Control and Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">SPIEN   </td><td class="markdownTableBodyLeft">SPI Transfer Control Bit And Busy Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If FIFO mode is enabled, this bit will be controlled by hardware and it's read only.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As the transfer is finished, this bit will be cleared automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Writing 0 to this bit to stop data transfer if SPI is transferring.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: When FIFO mode is disabled, all configurations should be ready before writing 1 to the SPIEN bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: In SPI Slave mode, if FIFO mode is disabled and the SPI bus clock is kept at idle state during a data transfer, the SPIEN bit will not be cleared to 0 when slave select signal goes to inactive state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RXNEG   </td><td class="markdownTableBodyLeft">Receive On Negative Edge    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The received data input signal latched on the rising-edge of SPI_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The received data input signal latched on the falling-edge of SPI_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TXNEG   </td><td class="markdownTableBodyLeft">Transmit On Negative Edge    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmitted data output signal is driven on the rising-edge of SPI_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmitted data output signal is driven on the falling-edge of SPI_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:3]   </td><td class="markdownTableBodyCenter">DWIDTH   </td><td class="markdownTableBodyLeft">Transmit Bit Length    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field specifies how many bits are transmitted in one transmit/receive.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The minimum bit length is 8 bits and can up to 32 bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">DWIDTH = 0x01~0x07 .... reserved (can't use).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">DWIDTH = 0x08 .... 8 bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">DWIDTH = 0x09 .... 9 bits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">......    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">DWIDTH = 0x1F .... 31 bits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">DWIDTH = 0x00 .... 32 bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">LSB   </td><td class="markdownTableBodyLeft">LSB First    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The MSB is transmitted/received first.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The LSB is transmitted/received first.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">CLKPOL   </td><td class="markdownTableBodyLeft">Clock Polarity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI_CLK idle low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI_CLK idle high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">SUSPITV   </td><td class="markdownTableBodyLeft">Suspend Interval (Master Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The four bits provide configurable suspend interval between two successive transactions in a transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default value is 0x3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The period of the suspend interval is obtained according to the following equation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(SUSPITV[3:0] + 0.5) * period of SPI_CLK clock cycle    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Example:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SUSPITV = 0x0 .... 0.5 SPI_CLK clock cycle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SUSPITV = 0x1 .... 1.5 SPI_CLK clock cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">......    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SUSPITV = 0xE .... 14.5 SPI_CLK clock cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SUSPITV = 0xF .... 15.5 SPI_CLK clock cycle.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">UNITIF   </td><td class="markdownTableBodyLeft">Unit-transfer Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transfer does not finish yet.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The SPI controller has finished one unit transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: This bit will be cleared by writing 1 to itself.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: It's a mutual mirror bit of SPI_STATUS[16].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">UNITIEN   </td><td class="markdownTableBodyLeft">Unit-transfer Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI unit-transfer interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI unit-transfer interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">SLAVE   </td><td class="markdownTableBodyLeft">Slave Mode Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Slave mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">REORDER   </td><td class="markdownTableBodyLeft">Byte Reorder Function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Byte reorder function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Byte reorder function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This setting is only available if DWIDTH is defined as 16, 24, or 32 bits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">FIFOEN   </td><td class="markdownTableBodyLeft">FIFO Mode Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = FIFO Mode Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = FIFO Mode Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: Before enabling FIFO mode, the other related settings should be set in advance.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: In Master mode, if the FIFO mode is enabled, the SPIEN bit will be set to 1 automatically after writing data into the 4-layer depth transmit FIFO.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When all data stored in transmit FIFO buffer are transferred, the SPIEN bit will back to .    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">RXEMPTY   </td><td class="markdownTableBodyLeft">Receive FIFO Buffer Empty Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The receive FIFO buffer is not empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The receive FIFO buffer is empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It's a mutual mirror bit of SPI_STATUS[24].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">RXFULL   </td><td class="markdownTableBodyLeft">Receive FIFO Buffer Full Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The receive FIFO buffer is not full.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The receive FIFO buffer is full.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It's a mutual mirror bit of SPI_STATUS[25]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">TXEMPTY   </td><td class="markdownTableBodyLeft">Transmit FIFO Buffer Empty Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmit FIFO buffer is not empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmit FIFO buffer is empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It's a mutual mirror bit of SPI_STAUTS[26].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">TXFULL   </td><td class="markdownTableBodyLeft">Transmit FIFO Buffer Full Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmit FIFO buffer is not full.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmit FIFO buffer is full.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It's a mutual mirror bit of SPI_STATUS[27].   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09061">9061</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gabb8d9df4695b742a04b52a7a64594322" name="gabb8d9df4695b742a04b52a7a64594322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb8d9df4695b742a04b52a7a64594322">&#9670;&nbsp;</a></span>CTL <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md264"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md265"></a>
Offset: 0x00  Timer0 Control and Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">PSC   </td><td class="markdownTableBodyLeft">Prescale Counter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this field is 0 (PSC = 0), then there is no scaling.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">CMPCTL   </td><td class="markdownTableBodyLeft">Timer Compared Mode Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The behavior selection in one-shot or periodic mode Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When user updates CMPDAT while timer is running in one-shot or periodic mode,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CNT will be reset to default value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The behavior selection in one-shot or periodic mode Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When user updates CMPDAT while timer is running in one-shot or periodic mode, the limitations as bellows list,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If updated CMPDAT value &gt; CNT, CMPDAT will be updated and CNT keep running continually.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If updated CMPDAT value = CNT, timer time-out interrupt will be asserted immediately.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If updated CMPDAT value &lt; CNT, CNT will be reset to default value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">TGLPINSEL   </td><td class="markdownTableBodyLeft">Toggle-output Pin Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Toggle mode output to TMx (Timer Event Counter Pin).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Toggle mode output to TMx_EXT (Timer External Capture Pin).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">CAPSRC   </td><td class="markdownTableBodyLeft">Capture Pin Source Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture Function source is from TMx_EXT (x= 0~1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture Function source is from internal ACMP output signal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User can set CAPSRCMP (TIMERx_EXTCTL[9]) to decide which ACMP output signal as timer capture source.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">WKEN   </td><td class="markdownTableBodyLeft">Wake-up Function Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is set to 1, while the timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up function Disabled if timer interrupt signal generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up function Enabled if timer interrupt signal generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">EXTCNTEN   </td><td class="markdownTableBodyLeft">Event Counter Mode Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is for external counting pin function enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Event counter mode Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Event counter mode Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">ACTSTS   </td><td class="markdownTableBodyLeft">Timer Active Status (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the 24-bit up counter status.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = 24-bit up counter is not active.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 24-bit up counter is active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">RSTCNT   </td><td class="markdownTableBodyLeft">Timer Counter Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will reset the 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[30]) to 0 if ACTSTS (TIMERx_CTL[25]) is 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[28:27]   </td><td class="markdownTableBodyCenter">OPMODE   </td><td class="markdownTableBodyLeft">Timer Counting Mode Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = The Timer controller is operated in one-shot mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = The Timer controller is operated in periodic mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = The Timer controller is operated in toggle-output mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = The Timer controller is operated in continuous counting mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29]   </td><td class="markdownTableBodyCenter">INTEN   </td><td class="markdownTableBodyLeft">Timer Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer Interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer Interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If this bit is enabled, when the timer interrupt flag TIF is set to 1, the timer interrupt signal will be generated and inform CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">CNTEN   </td><td class="markdownTableBodyLeft">Timer Counting Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stops/Suspends counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Starts counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: In stop status, and then setting CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is auto-cleared by hardware in one-shot mode (TIMERx_CTL[28:27] = 2'b00) when the timer interrupt flag TIF (TIMERx_INTSTS[0]) is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">ICEDEBUG   </td><td class="markdownTableBodyLeft">ICE Debug Mode Acknowledge Disable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ICE debug mode acknowledgement effects TIMER counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TIMER counter will be held while CPU is held by ICE.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ICE debug mode acknowledgement Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TIMER counter will keep going no matter CPU is held by ICE or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is write protected. Refer to the SYS_REGLCTL register.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10386">10386</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaee8e65be2579f6ca7675e9a63886ab42" name="gaee8e65be2579f6ca7675e9a63886ab42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8e65be2579f6ca7675e9a63886ab42">&#9670;&nbsp;</a></span>CTL <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WDT_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md304"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md305"></a>
Offset: 0x00  WDT Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RSTCNT   </td><td class="markdownTableBodyLeft">Reset WDT Up Counter (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset the internal 18-bit WDT up counter value.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is write protected. Refer to the SYS_REGLCTL register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit will be automatically cleared by hardware.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RSTEN   </td><td class="markdownTableBodyLeft">WDT Time-out Reset Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will enable the WDT time-out reset function If the WDT up counter value has not been cleared after the specific WDT reset delay period expires.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WDT time-out reset function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WDT time-out reset function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is write-protected. Refer to the SYS_REGLCTL register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RSTF   </td><td class="markdownTableBodyLeft">WDT Time-out Reset Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the system has been reset by WDT time-out reset or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WDT time-out reset did not occur.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WDT time-out reset occurred.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">IF   </td><td class="markdownTableBodyLeft">WDT Time-out Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit will be set to 1 while WDT up counter value reaches the selected WDT time-out interval    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WDT time-out interrupt did not occur.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WDT time-out interrupt occurred.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">WKEN   </td><td class="markdownTableBodyLeft">WDT Time-out Wake-up Function Control (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is set to 1, while WDT time-out interrupt flag IF (WDT_CTL[3]) is generated to 1 and interrupt enable bit INTEN (WDT_CTL[6]) is enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is write protected. Refer to the SYS_REGLCTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source is selected to LIRC or LXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">WKF   </td><td class="markdownTableBodyLeft">WDT Time-out Wake-up Flag (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the interrupt wake-up flag status of WDT    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WDT does not cause chip wake-up.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is write protected. Refer to the SYS_REGLCTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">INTEN   </td><td class="markdownTableBodyLeft">WDT Time-out Interrupt Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WDT time-out interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WDT time-out interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is write protected. Refer to the SYS_REGLCTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">WDTEN   </td><td class="markdownTableBodyLeft">WDT Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WDT Disabled (This action will reset the internal up counter value).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WDT Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is write protected. Refer to the SYS_REGLCTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: If CWDTEN[2:0] (combined by Config0[31] and Config0[4:3]) bits is not configure to 111, this bit is forced as 1 and user cannot change this bit to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10:8]   </td><td class="markdownTableBodyCenter">TOUTSEL   </td><td class="markdownTableBodyLeft">WDT Time-out Interval Selection (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These three bits select the time-out interval period for the WDT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">000 = 2^4 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">001 = 2^6 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">010 = 2^8 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">011 = 2^10 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">100 = 2^12 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">101 = 2^14 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">110 = 2^16 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">111 = 2^18 * WDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is write protected. Refer to the SYS_REGLCTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">ICEDEBUG   </td><td class="markdownTableBodyLeft">ICE Debug Mode Acknowledge Disable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ICE debug mode acknowledgement affects WDT counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">WDT up counter will be held while CPU is held by ICE.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ICE debug mode acknowledgement Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">WDT up counter will keep going no matter CPU is held by ICE or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is write protected. Refer to the SYS_REGLCTL register.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11454">11454</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga9cb6657ceeced88c80688cc910e43e60" name="ga9cb6657ceeced88c80688cc910e43e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cb6657ceeced88c80688cc910e43e60">&#9670;&nbsp;</a></span>CTL <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WWDT_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md310"></a>
CTL</h1>
<h2><a class="anchor" id="autotoc_md311"></a>
Offset: 0x04  WWDT Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WWDTEN   </td><td class="markdownTableBodyLeft">WWDT Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to enable WWDT counter counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WWDT counter is stopped.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WWDT counter is starting counting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">INTEN   </td><td class="markdownTableBodyLeft">WWDT Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WWDT counter compare match interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WWDT counter compare match interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">PSCSEL   </td><td class="markdownTableBodyLeft">WWDT Counter Prescale Period Select Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = Pre-scale is 1; Max time-out period is 1 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = Pre-scale is 2; Max time-out period is 2 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Pre-scale is 4; Max time-out period is 4 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Pre-scale is 8; Max time-out period is 8 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = Pre-scale is 16; Max time-out period is 16 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = Pre-scale is 32; Max time-out period is 32 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = Pre-scale is 64; Max time-out period is 64 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = Pre-scale is 128; Max time-out period is 128 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = Pre-scale is 192; Max time-out period is 192 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Pre-scale is 256; Max time-out period is 256 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1010 = Pre-scale is 384; Max time-out period is 384 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1011 = Pre-scale is 512; Max time-out period is 512 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1100 = Pre-scale is 768; Max time-out period is 768 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * WWDT_CLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">CMPDAT   </td><td class="markdownTableBodyLeft">WWDT Window Compare Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this register to adjust the valid reload window.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If user writes WWDT_RLDCNT register when current WWDT counter value larger than CMPDAT, WWDT reset signal will generate immediately.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">ICEDEBUG   </td><td class="markdownTableBodyLeft">ICE Debug Mode Acknowledge Disable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ICE debug mode acknowledgement effects WWDT counting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">WWDT down counter will be held while CPU is held by ICE.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ICE debug mode acknowledgement Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">WWDT down counter will keep going no matter CPU is held by ICE or not.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11585">11585</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga709765ae65421d9d51aa7539684197ac" name="ga709765ae65421d9d51aa7539684197ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga709765ae65421d9d51aa7539684197ac">&#9670;&nbsp;</a></span>CTL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::CTL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md110"></a>
CTL1</h1>
<h2><a class="anchor" id="autotoc_md111"></a>
Offset: 0x3C  I2C Control Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WKEN   </td><td class="markdownTableBodyLeft">Wake-up Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C wake-up function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C wake-up function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The system can be woken up by I2C bus when the system is set into Power mode and the received data matched one of the addresses in Address Register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Only I2C0 channel supports wake-up function. This bit is not valid on I2C1 channel.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TWOLVFIFO   </td><td class="markdownTableBodyLeft">Two-level Buffer Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Two-level buffer Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Two-level buffer Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set to enable the two-level buffer for I2C transmitted or received buffer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to improve the performance of the I2C bus.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is set = 1, the control bit of STA for repeat start or STO bit should be set after the current SI is clear.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example: if there are 4 data shall be transmitted and then stop it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The STO bit shall be set after the 3rd data's SI event being clear.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In this time, the 4th data can be transmitted and the I2C stop after the 4th data transmission don.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">NSTRETCH   </td><td class="markdownTableBodyLeft">No Stretch On The I2C Bus    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The I2C SCL bus is stretched by hardware if the SI is not cleared in master mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The I2C SCL bus is not stretched by hardware if the SI is not cleared in master mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">OVIEN   </td><td class="markdownTableBodyLeft">I2C Overrun Interrupt Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting OVIEN to 1 will send a interrupt to system when the TWOLVFF bit is enabled and there is overrun event in received buffer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Overrun Interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Overrun Interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">URIEN   </td><td class="markdownTableBodyLeft">I2C Under Run Interrupt Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting URIEN to 1 will send a interrupt to system when the TWOLVFF bit is enabled and there is under run event happened in transmitted buffer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Under run Interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Under run Interrupt Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04812">4812</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga55dff1581fa36f47d3b1f629dc9f0695" name="ga55dff1581fa36f47d3b1f629dc9f0695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55dff1581fa36f47d3b1f629dc9f0695">&#9670;&nbsp;</a></span>DAT <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t ADC_T::DAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md6"></a>
DAT</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Offset: 0x00  A/D Data Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9:0]   </td><td class="markdownTableBodyCenter">RESULT   </td><td class="markdownTableBodyLeft">A/D Conversion Result    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field contains conversion result of ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">OV   </td><td class="markdownTableBodyLeft">Over Run Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If converted data in RESULT[9:0] has not been read before the new conversion result is loaded to this register, OV is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is cleared by hardware after the ADC_DAT register is rea.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Data in RESULT[9:0] is recent conversion result.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Data in RESULT[9:0] overwrote.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">VALID   </td><td class="markdownTableBodyLeft">Valid Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to 1 when ADC conversion is completed and cleared by hardware after the ADC_DAT register is read.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Data in RESULT[9:0] bits not valid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Data in RESULT[9:0] bits valid.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00344">344</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga158d79b640465c2687994504ceb19c42" name="ga158d79b640465c2687994504ceb19c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga158d79b640465c2687994504ceb19c42">&#9670;&nbsp;</a></span>DAT <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::DAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md88"></a>
DAT</h1>
<h2><a class="anchor" id="autotoc_md89"></a>
Offset: 0x08  I2C DATA Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">DAT   </td><td class="markdownTableBodyLeft">I2C Data Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bit [7:0] is located with the 8-bit transferred data of the I2C serial port.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04615">4615</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga24820b94bbd2706f85d2bbed473fbd2c" name="ga24820b94bbd2706f85d2bbed473fbd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24820b94bbd2706f85d2bbed473fbd2c">&#9670;&nbsp;</a></span>DAT <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::DAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md278"></a>
DAT</h1>
<h2><a class="anchor" id="autotoc_md279"></a>
Offset: 0x00  UART Receive/Transmit Buffer Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">DAT   </td><td class="markdownTableBodyLeft">Receiving/Transmit Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By writing one byte to this register, the data byte will be stored in transmitter FIFO.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The UART Controller will send out the data stored in transmitter FIFO top location through the UART_TX.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">By reading this register, the UART will return an 8-bit data received from receiving FIFO.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10719">10719</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga210328cdbb34226b4526f2a302bdf19e" name="ga210328cdbb34226b4526f2a302bdf19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga210328cdbb34226b4526f2a302bdf19e">&#9670;&nbsp;</a></span>DATMSK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::DATMSK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md70"></a>
DATMSK</h1>
<h2><a class="anchor" id="autotoc_md71"></a>
Offset: 0x0C  P0 Data Output Write Mask</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">DATMSK0   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Data Output Write Mask    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the write signal is masked, writing data to the protect bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding DOUT (Px_DOUT[n]) bit protected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">DATMSK1   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Data Output Write Mask    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the write signal is masked, writing data to the protect bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding DOUT (Px_DOUT[n]) bit protected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">DATMSK2   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Data Output Write Mask    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the write signal is masked, writing data to the protect bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding DOUT (Px_DOUT[n]) bit protected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">DATMSK3   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Data Output Write Mask    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the write signal is masked, writing data to the protect bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding DOUT (Px_DOUT[n]) bit protected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">DATMSK4   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Data Output Write Mask    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the write signal is masked, writing data to the protect bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding DOUT (Px_DOUT[n]) bit protected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">DATMSK5   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Data Output Write Mask    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the write signal is masked, writing data to the protect bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding DOUT (Px_DOUT[n]) bit protected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">DATMSK6   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Data Output Write Mask    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the write signal is masked, writing data to the protect bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding DOUT (Px_DOUT[n]) bit protected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">DATMSK7   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Data Output Write Mask    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the write signal is masked, writing data to the protect bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Corresponding DOUT (Px_DOUT[n]) bit protected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l02077">2077</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga85770c088c53797e0c7a2c04aff5aa04" name="ga85770c088c53797e0c7a2c04aff5aa04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85770c088c53797e0c7a2c04aff5aa04">&#9670;&nbsp;</a></span>DBCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_DB_T::DBCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md82"></a>
DBCTL</h1>
<h2><a class="anchor" id="autotoc_md83"></a>
Offset: 0x180  De-bounce Cycle Control</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">DBCLKSEL   </td><td class="markdownTableBodyLeft">De-bounce Sampling Cycle Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = Sample interrupt input once per 1 clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = Sample interrupt input once per 2 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = Sample interrupt input once per 4 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = Sample interrupt input once per 8 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0100 = Sample interrupt input once per 16 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0101 = Sample interrupt input once per 32 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0110 = Sample interrupt input once per 64 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0111 = Sample interrupt input once per 128 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1000 = Sample interrupt input once per 256 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1001 = Sample interrupt input once per 2*256 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1010 = Sample interrupt input once per 4*256 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1011 = Sample interrupt input once per 8*256 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1100 = Sample interrupt input once per 16*256 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1101 = Sample interrupt input once per 32*256 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1110 = Sample interrupt input once per 64*256 clocks.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1111 = Sample interrupt input once per 128*256 clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">DBCLKSRC   </td><td class="markdownTableBodyLeft">De-bounce Counter Clock Source Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = De-bounce counter clock source is HCLK.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = De-bounce counter clock source is 10 kHz internal low speed RC oscillator (LIRC).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">ICLKON   </td><td class="markdownTableBodyLeft">Interrupt Clock On Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge detection circuit is active only if I/O pin corresponding RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]) bit is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = All I/O pins edge detection circuit is always active after reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It is recommended to disable this bit to save system power if no special application concern.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l02974">2974</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gad3d4810bebd87d723aa1c2553576bc95" name="gad3d4810bebd87d723aa1c2553576bc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3d4810bebd87d723aa1c2553576bc95">&#9670;&nbsp;</a></span>DBEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::DBEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md74"></a>
DBEN</h1>
<h2><a class="anchor" id="autotoc_md75"></a>
Offset: 0x14  P0 De-bounce Enable Control</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">DBEN0   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Input Signal De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n de-bounce function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n de-bounce function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">DBEN1   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Input Signal De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n de-bounce function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n de-bounce function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">DBEN2   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Input Signal De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n de-bounce function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n de-bounce function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">DBEN3   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Input Signal De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n de-bounce function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n de-bounce function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">DBEN4   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Input Signal De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n de-bounce function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n de-bounce function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">DBEN5   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Input Signal De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n de-bounce function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n de-bounce function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">DBEN6   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Input Signal De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n de-bounce function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n de-bounce function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">DBEN7   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Input Signal De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n de-bounce function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n de-bounce function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l02305">2305</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8147f850e50804a8dfe1021999a4d7db" name="ga8147f850e50804a8dfe1021999a4d7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8147f850e50804a8dfe1021999a4d7db">&#9670;&nbsp;</a></span>DFBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t FMC_T::DFBA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md58"></a>
DFBA</h1>
<h2><a class="anchor" id="autotoc_md59"></a>
Offset: 0x14  Data Flash Base Address</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">DFBA   </td><td class="markdownTableBodyLeft">Data Flash Base Address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This register indicates Data Flash start address. It is a read only register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Flash is shared with APROM. the content of this register is loaded from CONFIG1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This register is valid when DFEN (CONFIG0[0]) =0 .   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01475">1475</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaaab1b732a5fab67f022435f45d689ca3" name="gaaab1b732a5fab67f022435f45d689ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaab1b732a5fab67f022435f45d689ca3">&#9670;&nbsp;</a></span>DINOFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::DINOFF</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md66"></a>
DINOFF</h1>
<h2><a class="anchor" id="autotoc_md67"></a>
Offset: 0x04  P0 Digital Input Path Disable Control</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">DINOFF0   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Digital Input Path Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n digital input path Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n digital input path Disabled (digital input tied to low).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">DINOFF1   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Digital Input Path Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n digital input path Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n digital input path Disabled (digital input tied to low).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">DINOFF2   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Digital Input Path Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n digital input path Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n digital input path Disabled (digital input tied to low).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">DINOFF3   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Digital Input Path Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n digital input path Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n digital input path Disabled (digital input tied to low).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">DINOFF4   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Digital Input Path Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n digital input path Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n digital input path Disabled (digital input tied to low).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">DINOFF5   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Digital Input Path Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n digital input path Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n digital input path Disabled (digital input tied to low).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">DINOFF6   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Digital Input Path Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n digital input path Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n digital input path Disabled (digital input tied to low).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">DINOFF7   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Digital Input Path Disable Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n digital input path Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n digital input path Disabled (digital input tied to low).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01857">1857</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gacedf474a76d41eb49d93ca976fa0afa4" name="gacedf474a76d41eb49d93ca976fa0afa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacedf474a76d41eb49d93ca976fa0afa4">&#9670;&nbsp;</a></span>DOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::DOUT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md68"></a>
DOUT</h1>
<h2><a class="anchor" id="autotoc_md69"></a>
Offset: 0x08  P0 Data Output Value</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">DOUT0   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Output Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">DOUT1   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Output Value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">DOUT2   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Output Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">DOUT3   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Output Value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">DOUT4   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Output Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">DOUT5   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Output Value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">DOUT6   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Output Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">DOUT7   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Output Value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01955">1955</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gae1392cfa1ca77df4619334c2f8133a9f" name="gae1392cfa1ca77df4619334c2f8133a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1392cfa1ca77df4619334c2f8133a9f">&#9670;&nbsp;</a></span>DTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::DTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md196"></a>
DTCTL</h1>
<h2><a class="anchor" id="autotoc_md197"></a>
Offset: 0x64  PWM Dead-time Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">DTI01   </td><td class="markdownTableBodyLeft">Dead-time Interval Register For Pair Of Channel0 And Channel1 (PWM0_CH0 And PWM0_CH1 Pair)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These 8 bits determine dead-time length.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The unit time of dead-time length is received from corresponding PWM_CLKDIV bits.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:8]   </td><td class="markdownTableBodyCenter">DTI23   </td><td class="markdownTableBodyLeft">Dead-time Interval Register For Pair Of Channel2 And Channel3 (PWM0_CH2 And PWM0_CH3 Pair)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These 8 bits determine dead-time length.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The unit time of dead-time length is received from corresponding PWM_CLKDIV bits.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">DTI45   </td><td class="markdownTableBodyLeft">Dead-time Interval Register For Pair Of Channel4 And Channel5 (PWM0_CH4 And PWM0_CH5 Pair)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These 8 bits determine dead-time length.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The unit time of dead-time length is received from corresponding PWM_CLKDIV bits.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07275">7275</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga22b29c334e8055b04d7248ab845ee99b" name="ga22b29c334e8055b04d7248ab845ee99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22b29c334e8055b04d7248ab845ee99b">&#9670;&nbsp;</a></span>EINTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::EINTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md276"></a>
EINTSTS</h1>
<h2><a class="anchor" id="autotoc_md277"></a>
Offset: 0x18  Timer0 External Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CAPIF   </td><td class="markdownTableBodyLeft">Timer External Capture Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the timer external capture interrupt flag status.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMx_EXT (x= 0~1) pin interrupt did not occur.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMx_EXT (x= 0~1) pin interrupt occurred.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on TMx_EXT (x= 0~1) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10520">10520</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gae4873e6bfb7ee6a7bf36a4a0d4d9f4f9" name="gae4873e6bfb7ee6a7bf36a4a0d4d9f4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4873e6bfb7ee6a7bf36a4a0d4d9f4f9">&#9670;&nbsp;</a></span>EXTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::EXTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md274"></a>
EXTCTL</h1>
<h2><a class="anchor" id="autotoc_md275"></a>
Offset: 0x14  Timer0 External Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CNTPHASE   </td><td class="markdownTableBodyLeft">Timer External Count Phase    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the detection phase of external counting pin TMx (x= 0~1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = A falling edge of external counting pin will be counted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = A rising edge of external counting pin will be counted.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2:1]   </td><td class="markdownTableBodyCenter">CAPEDGE   </td><td class="markdownTableBodyLeft">Timer External Capture Pin Edge Detection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = A falling edge on TMx_EXT (x= 0~1) pin will be detected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = A rising edge on TMx_EXT (x= 0~1) pin will be detected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Either rising or falling edge on TMx_EXT (x= 0~1) pin will be detected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">CAPEN   </td><td class="markdownTableBodyLeft">Timer External Capture Pin Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit enables the TMx_EXT pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMx_EXT (x= 0~1) pin Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMx_EXT (x= 0~1) pin Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CAPFUNCS   </td><td class="markdownTableBodyLeft">Capture Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = External Capture Mode Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = External Reset Mode Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: When CAPFUNCS is 0, transition on TMx_EXT (x= 0~1) pin is using to save the 24-bit timer counter value to CAPDAT register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: When CAPFUNCS is 1, transition on TMx_EXT (x= 0~1) pin is using to reset the 24-bit timer counter value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">CAPIEN   </td><td class="markdownTableBodyLeft">Timer External Capture Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMx_EXT (x= 0~1) pin detection Interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMx_EXT (x= 0~1) pin detection Interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: CAPIEN is used to enable timer external interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CAPIEN enabled, timer will generate an interrupt when CAPIF (TIMERx_EINTSTS[0]) is .    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, an 1 to 0 transition on the TMx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">CAPDBEN   </td><td class="markdownTableBodyLeft">Timer External Capture Pin De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMx_EXT (x= 0~1) pin de-bounce Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMx_EXT (x= 0~1) pin de-bounce Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: The de-bounce circuit doesn't support ACMP output.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CNTDBEN   </td><td class="markdownTableBodyLeft">Timer Counter Pin De-bounce Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMx (x= 0~1) pin de-bounce Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMx (x= 0~1) pin de-bounce Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CAPSEL   </td><td class="markdownTableBodyLeft">Capture Mode Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer counter reset function or free-counting mode of timer capture function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Trigger-counting mode of timer capture function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">ACMPSSEL   </td><td class="markdownTableBodyLeft">ACMP Source Selection to Trigger Capture Function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For Timer 0:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture Function source is from ACMP0 output signal for TIMER0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture Function source is from ACMP1 output signal for TIMER0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For Timer 1:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Capture Function source is from ACMP1 output signal for TIMER1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Capture Function source is from ACMP0 output signal for TIMER1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10502">10502</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaa44b3c2b019b385f646595a951c258a6" name="gaa44b3c2b019b385f646595a951c258a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa44b3c2b019b385f646595a951c258a6">&#9670;&nbsp;</a></span>EXTSMPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::EXTSMPT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md20"></a>
EXTSMPT</h1>
<h2><a class="anchor" id="autotoc_md21"></a>
Offset: 0x48  A/D Sampling Time Counter Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">EXTSMPT   </td><td class="markdownTableBodyLeft">Additional ADC Sample Clock    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the ADC input is unstable, user can set this register to increase the sampling time to get a stable ADC input signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default sampling time is 1 ADC clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The additional clock number will be inserted to lengthen the sampling clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Number of additional clock cycles is 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Number of additional clock cycles is 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">2 = Number of additional clock cycles is 2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">3 = Number of additional clock cycles is 4.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">4 = Number of additional clock cycles is 8.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">5 = Number of additional clock cycles is 16.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">6 = Number of additional clock cycles is 32.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">7 = Number of additional clock cycles is 64.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">8 = Number of additional clock cycles is 128.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">9 = Number of additional clock cycles is 256.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Number of additional clock cycles is 512.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Number of additional clock cycles is 1024.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">12 = Number of additional clock cycles is 1024.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">13 = Number of additional clock cycles is 1024.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">14 = Number of additional clock cycles is 1024.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">15 = Number of additional clock cycles is 1024.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00567">567</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga039cda92f876c6b845b86855765d60cd" name="ga039cda92f876c6b845b86855765d60cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga039cda92f876c6b845b86855765d60cd">&#9670;&nbsp;</a></span>FATCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::FATCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md60"></a>
FATCTL</h1>
<h2><a class="anchor" id="autotoc_md61"></a>
Offset: 0x18  Flash Access Time Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">FOM   </td><td class="markdownTableBodyLeft">Frequency Optimization Mode (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Mini58 series supports adjustable flash access timing to optimize the flash access cycles in different working frequency.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x1 = Frequency &lt;= 24MHz.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Frequency &lt;= 50MHz.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01489">1489</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8a2724052e91db61cb0437ff9716bca2" name="ga8a2724052e91db61cb0437ff9716bca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a2724052e91db61cb0437ff9716bca2">&#9670;&nbsp;</a></span>FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::FIFO</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md282"></a>
FIFO</h1>
<h2><a class="anchor" id="autotoc_md283"></a>
Offset: 0x08  UART FIFO Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RXRST   </td><td class="markdownTableBodyLeft">RX Field Software Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When RX_RST is set, all the byte in the receiver FIFO and RX internal state machine are cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset RX internal state machine and pointers reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will auto clear needs at least 3 UART Controller peripheral clock cycles.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TXRST   </td><td class="markdownTableBodyLeft">TX Field Software Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When TX_RST is set, all the byte in the transmit FIFO and TX internal state machine are cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Reset TX internal state machine and pointers reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will auto clear needs at least 3 UART Controller peripheral clock cycles.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">RFITL   </td><td class="markdownTableBodyLeft">RX FIFO Interrupt (RDAINT) Trigger Level (Only Available In UART0)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the number of bytes in the receive FIFO equals the RFITL then the RDAIF will be set (if RDAIEN in UART_INTEN register is enable, an interrupt will generated).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = RX FIFO Interrupt Trigger Level is 1 byte.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = RX FIFO Interrupt Trigger Level is 4 bytes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = RX FIFO Interrupt Trigger Level is 8 bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = RX FIFO Interrupt Trigger Level is 14 bytes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Other = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">RXOFF   </td><td class="markdownTableBodyLeft">Receiver Disable Register (Only Available In UART0)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The receiver is disabled or not (setting 1 to disable the receiver).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Receiver Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receiver Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is used for RS-485 Normal Multi-drop mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It should be programmed before RS-485_NMM (UART_ALTCTL [8]) is programme.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">RTSTRGLV   </td><td class="markdownTableBodyLeft">RTS Trigger Level (For Auto-flow Control Use) (Only Available In UART0)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0000 = RTS Trigger Level is 1 byte.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0001 = RTS Trigger Level is 4 bytes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0010 = RTS Trigger Level is 8 bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0011 = RTS Trigger Level is 14 bytes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Other = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This field is used for RTS auto-flow control.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10802">10802</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8ea825ffc93dccfd0ef04d389fc38e52" name="ga8ea825ffc93dccfd0ef04d389fc38e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ea825ffc93dccfd0ef04d389fc38e52">&#9670;&nbsp;</a></span>FIFOCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::FIFOCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md230"></a>
FIFOCTL</h1>
<h2><a class="anchor" id="autotoc_md231"></a>
Offset: 0x40  SPI FIFO Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RXRST   </td><td class="markdownTableBodyLeft">Clear Receive FIFO Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear receive FIFO buffer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be cleared to 0 by hardware after software sets it to 1 and the receive FIFO is cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TXRST   </td><td class="markdownTableBodyLeft">Clear Transmit FIFO Buffer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear transmit FIFO buffer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be cleared to 0 by hardware after software sets it to 1 and the transmit FIFO is cleared.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RXTHIEN   </td><td class="markdownTableBodyLeft">Receive Threshold Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Receive threshold interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receive threshold interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TXTHIEN   </td><td class="markdownTableBodyLeft">Transmit Threshold Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transmit threshold interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transmit threshold interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">RXOVIEN   </td><td class="markdownTableBodyLeft">Receive FIFO Overrun Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Receive    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIFO overrun interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Receive    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">FIFO overrun interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">RXTOIEN   </td><td class="markdownTableBodyLeft">Receive FIFO Time-out Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Time-out interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time-out interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25:24]   </td><td class="markdownTableBodyCenter">RXTH   </td><td class="markdownTableBodyLeft">Receive FIFO Threshold    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the valid data count of the receive FIFO buffer is larger than the RXTH setting, the RXTHIF bit will be set to 1, else the RXTHIF bit will be cleared to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:28]   </td><td class="markdownTableBodyCenter">TXTH   </td><td class="markdownTableBodyLeft">Transmit FIFO Threshold    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the valid data count of the transmit FIFO buffer is less than or equal to the TXTH setting, the TXTHIF bit will be set to 1, else the TXTHIF bit will be cleared to 0.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09235">9235</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga611e6f66dfde1440b9fdc846731b5c49" name="ga611e6f66dfde1440b9fdc846731b5c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga611e6f66dfde1440b9fdc846731b5c49">&#9670;&nbsp;</a></span>FIFOSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::FIFOSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md290"></a>
FIFOSTS</h1>
<h2><a class="anchor" id="autotoc_md291"></a>
Offset: 0x18  UART FIFO Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RXOVIF   </td><td class="markdownTableBodyLeft">RX Overflow Error Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when RX FIFO overflow.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, 16 bytes this bit will be set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO did not overflow.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO overflowed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">ADDRDETF   </td><td class="markdownTableBodyLeft">RS-485 Address Byte Detection Flag (Only Available In UART0)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to 1 while ADDRDEN (UART_ALTCTL[15]) is set to 1 to enable Address detection mode and receive detect a data with an address bit (bit 9 = 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This field is used for RS-485 function mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">PEF   </td><td class="markdownTableBodyLeft">Parity Error Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic 1 whenever the received character does not have a valid "parity bit".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No parity error is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Parity error is generate.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing '1' to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">FEF   </td><td class="markdownTableBodyLeft">Framing Error Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit follows the last data bit or parity bit is detected as logic 0).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No framing error is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Framing error is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but can be cleared by writing '1' to it .    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BIF   </td><td class="markdownTableBodyLeft">Break Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to logic 1 whenever the received data input (RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Break interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Break interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only, but software can write 1 to clear it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">RXPTR   </td><td class="markdownTableBodyLeft">RX FIFO Pointer (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the RX FIFO Buffer Pointer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When UART receives one byte from external device, RXPTR increases one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When one byte of RX FIFO is read by CPU, RXPTR decreases on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Maximum value shown in RXPTR is 15.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">RXEMPTY   </td><td class="markdownTableBodyLeft">Receiver FIFO Empty (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit initiate RX FIFO empty or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO is not empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO is empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It will be cleared when UART receives any new data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">RXFULL   </td><td class="markdownTableBodyLeft">Receiver FIFO Full (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit initiates RX FIFO full or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RX FIFO is not full.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RX FIFO is full.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">TXPTR   </td><td class="markdownTableBodyLeft">TX FIFO Pointer (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field indicates the TX FIFO Buffer Pointer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When CPU writes one byte into UART_DAT, TXPTR increases one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Maximum value shown in TXPTR is 15.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">TXEMPTY   </td><td class="markdownTableBodyLeft">Transmitter FIFO Empty (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates TX FIFO empty or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX FIFO is not empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX FIFO is empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It will be cleared when writing data into THR (TX FIFO not empty).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">TXFULL   </td><td class="markdownTableBodyLeft">Transmitter FIFO Full (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates TX FIFO full or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX FIFO is not full.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX FIFO is full.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">TXOVIF   </td><td class="markdownTableBodyLeft">TX Overflow Error Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">logic 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX FIFO did not overflow.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX FIFO overflowed.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">TXEMPTYF   </td><td class="markdownTableBodyLeft">Transmitter Empty Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TX FIFO is not empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TX FIFO is empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10969">10969</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2a02d5c7120ffa3e209cdafcf7e97f03" name="ga2a02d5c7120ffa3e209cdafcf7e97f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a02d5c7120ffa3e209cdafcf7e97f03">&#9670;&nbsp;</a></span>FUNSEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::FUNSEL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md302"></a>
FUNSEL</h1>
<h2><a class="anchor" id="autotoc_md303"></a>
Offset: 0x30  UART Function Select Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">FUN_SEL   </td><td class="markdownTableBodyLeft">Function Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = UART function mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = IrDA function mode. (Only Available in UART0)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = RS-485 function mode. (Only Available in UART0)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11156">11156</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaf244c7a0518aff801a61660751055701" name="gaf244c7a0518aff801a61660751055701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf244c7a0518aff801a61660751055701">&#9670;&nbsp;</a></span>IFA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::IFA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md212"></a>
IFA</h1>
<h2><a class="anchor" id="autotoc_md213"></a>
Offset: 0x84  PWM Period Interrupt Accumulation Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">IFAEN   </td><td class="markdownTableBodyLeft">Interrupt Accumulation Function Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Interrupt accumulation function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Interrupt accumulation function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:4]   </td><td class="markdownTableBodyCenter">IFCNT   </td><td class="markdownTableBodyLeft">Interrupt Accumulation Counter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When IFAEN is set, IFCNT will decrease when every ZIFn flag is set and when IFCNT reach to zero, the PWMn interrupt will occurred and IFCNT will reload itself.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07822">7822</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2954225147cc4d89f9431fa5aeec33e2" name="ga2954225147cc4d89f9431fa5aeec33e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2954225147cc4d89f9431fa5aeec33e2">&#9670;&nbsp;</a></span>INTEN <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::INTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md78"></a>
INTEN</h1>
<h2><a class="anchor" id="autotoc_md79"></a>
Offset: 0x1C  P0 Interrupt Enable Control</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">FLIEN0   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the FLIEN (Px_INTEN[n]) bit to 1:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level low or high to low interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level low or high to low interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">FLIEN1   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the FLIEN (Px_INTEN[n]) bit to 1:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level low or high to low interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level low or high to low interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">FLIEN2   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the FLIEN (Px_INTEN[n]) bit to 1:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level low or high to low interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level low or high to low interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">FLIEN3   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the FLIEN (Px_INTEN[n]) bit to 1:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level low or high to low interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level low or high to low interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">FLIEN4   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the FLIEN (Px_INTEN[n]) bit to 1:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level low or high to low interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level low or high to low interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">FLIEN5   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the FLIEN (Px_INTEN[n]) bit to 1:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level low or high to low interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level low or high to low interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">FLIEN6   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the FLIEN (Px_INTEN[n]) bit to 1:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level low or high to low interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level low or high to low interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">FLIEN7   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the FLIEN (Px_INTEN[n]) bit to 1function    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level low or high to low interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level low or high to low interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">RHIEN0   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the RHIEN (Px_INTEN[n+16]) bit to 1:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level high or low to high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level high or low to high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">RHIEN1   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the RHIEN (Px_INTEN[n+16]) bit to 1:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level high or low to high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level high or low to high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">RHIEN2   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the RHIEN (Px_INTEN[n+16]) bit to 1:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level high or low to high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level high or low to high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">RHIEN3   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the RHIEN (Px_INTEN[n+16]) bit to 1:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level high or low to high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level high or low to high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">RHIEN4   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the RHIEN (Px_INTEN[n+16]) bit to 1:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level high or low to high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level high or low to high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[21]   </td><td class="markdownTableBodyCenter">RHIEN5   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the RHIEN (Px_INTEN[n+16]) bit to 1:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level high or low to high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level high or low to high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">RHIEN6   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the RHIEN (Px_INTEN[n+16]) bit to 1:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level high or low to high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level high or low to high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">RHIEN7   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set bit to 1 also enable the pin wake-up function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting the RHIEN (Px_INTEN[n+16]) bit to 1:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Px.n level high or low to high interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n level high or low to high interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l02701">2701</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga1fbc063a076e84e9b8f17ebcee04879e" name="ga1fbc063a076e84e9b8f17ebcee04879e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fbc063a076e84e9b8f17ebcee04879e">&#9670;&nbsp;</a></span>INTEN <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::INTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md188"></a>
INTEN</h1>
<h2><a class="anchor" id="autotoc_md189"></a>
Offset: 0x54  PWM Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIEN0   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn zero point interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn zero point interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIEN1   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn zero point interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn zero point interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIEN2   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn zero point interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn zero point interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIEN3   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn zero point interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn zero point interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIEN4   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn zero point interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn zero point interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIEN5   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn zero point interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn zero point interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIEN0   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare down interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare down interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIEN1   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare down interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare down interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIEN2   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare down interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare down interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIEN3   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare down interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare down interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIEN4   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare down interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare down interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIEN5   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare down interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare down interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">BRKIEN   </td><td class="markdownTableBodyLeft">Fault Brake0 And Fault Brake1 Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = BRKIF0 and BRKIF1 trigger PWM interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = BRKIF0 and BRKIF1 trigger PWM interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">PINTTYPE   </td><td class="markdownTableBodyLeft">PWM Interrupt Type Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ZIFn will be set if PWM counter underflows.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ZIFn will be set if PWM counter matches PERIODn register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is effective when PWM is in center-aligned type only.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIEN0   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn period interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn period interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIEN1   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn period interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn period interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIEN2   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn period interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn period interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIEN3   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn period interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn period interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIEN4   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn period interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn period interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIEN5   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn period interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn period interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIEN0   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare up interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare up interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIEN1   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare up interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare up interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIEN2   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare up interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare up interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIEN3   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare up interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare up interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIEN4   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare up interrupt Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare up interrupt Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIEN5   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn compare up interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn compare up interrupt Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07076">7076</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0418d4cfbebf1037e83200b1d2e91ad3" name="ga0418d4cfbebf1037e83200b1d2e91ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0418d4cfbebf1037e83200b1d2e91ad3">&#9670;&nbsp;</a></span>INTEN <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::INTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md280"></a>
INTEN</h1>
<h2><a class="anchor" id="autotoc_md281"></a>
Offset: 0x04  UART Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RDAIEN   </td><td class="markdownTableBodyLeft">Receive Data Available Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RDAINT Masked off.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RDAINT Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">THREIEN   </td><td class="markdownTableBodyLeft">Transmit Holding Register Empty Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = THREINT Masked off.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = THREINT Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RLSIEN   </td><td class="markdownTableBodyLeft">Receive Line Status Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RLSINT Masked off.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RLSINT Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">MODEMIEN   </td><td class="markdownTableBodyLeft">Modem Status Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = MODEMINT Masked off.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = MODEMINT Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">RXTOIEN   </td><td class="markdownTableBodyLeft">RX Time-out Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RXTOINT Masked off.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RXTOINT Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">BUFERRIEN   </td><td class="markdownTableBodyLeft">Buffer Error Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Buffer Error Interrupt Masked Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Buffer Error Interrupt Masked Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">WKCTSIEN   </td><td class="markdownTableBodyLeft">Wake-up CPU Function Interrupt Enable Bit (Only Available In UART0)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = UART wake-up function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = UART Wake-up function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">TOCNTEN   </td><td class="markdownTableBodyLeft">Time-out Counter Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Time-out counter Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time-out counter Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">ATORTSEN   </td><td class="markdownTableBodyLeft">RTS Auto Flow Control Enable Bit (Only Available In UART0)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTS auto flow control Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTS auto flow control Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_FIFO [19:16]), the UART will de-assert RTS signal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">ATOCTSEN   </td><td class="markdownTableBodyLeft">CTS Auto Flow Control Enable Bit (Only Available In UART0)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CTS auto flow control Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CTS auto flow control Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10762">10762</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga791263d0be410c056405a90bf7ff81c5" name="ga791263d0be410c056405a90bf7ff81c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga791263d0be410c056405a90bf7ff81c5">&#9670;&nbsp;</a></span>INTSRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::INTSRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md80"></a>
INTSRC</h1>
<h2><a class="anchor" id="autotoc_md81"></a>
Offset: 0x20  P0 Interrupt Source Flag</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">INTSRC0   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">INTSRC1   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">INTSRC2   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">INTSRC3   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">INTSRC4   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">INTSRC5   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">INTSRC6   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">INTSRC7   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">INTSRC8   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">INTSRC9   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">INTSRC10   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">INTSRC11   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">INTSRC12   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">INTSRC13   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">INTSRC14   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">INTSRC15   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Interrupt Source Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write Operation:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No action.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clear the corresponding pending interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read Operation:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No interrupt at Px.n.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Px.n generates an interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l02935">2935</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gac535addafa0eb3c00a1fba2f4d845451" name="gac535addafa0eb3c00a1fba2f4d845451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac535addafa0eb3c00a1fba2f4d845451">&#9670;&nbsp;</a></span>INTSTS <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md190"></a>
INTSTS</h1>
<h2><a class="anchor" id="autotoc_md191"></a>
Offset: 0x58  PWM Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIF0   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches zero point.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIF1   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches zero point.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIF2   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches zero point.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIF3   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches zero point.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIF4   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches zero point.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">ZIF5   </td><td class="markdownTableBodyLeft">PWM Zero Point Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches zero point.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIF0   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches CMPn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIF1   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches CMPn.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIF2   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches CMPn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIF3   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches CMPn.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIF4   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches CMPn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">CMPDIF5   </td><td class="markdownTableBodyLeft">PWM Compare Down Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWMn counter down count reaches CMPn.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">BRKIF0   </td><td class="markdownTableBodyLeft">PWM Brake0 Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM Brake does not recognize a falling signal at BKP0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = When PWM Brake detects a falling signal at pin BKP0; this flag will be set to high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">BRKIF1   </td><td class="markdownTableBodyLeft">PWM Brake1 Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM Brake does not recognize a falling signal at BKP1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = When PWM Brake detects a falling signal at pin BKP1; this flag will be set to high.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIF0   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter reaches PERIODn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIF1   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter reaches PERIODn.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIF2   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter reaches PERIODn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIF3   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter reaches PERIODn.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIF4   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter reaches PERIODn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:18]   </td><td class="markdownTableBodyCenter">PIF5   </td><td class="markdownTableBodyLeft">PWM Period Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter reaches PERIODn.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIF0   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIF1   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIF2   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIF3   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIF4   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:24]   </td><td class="markdownTableBodyCenter">CMPUIF5   </td><td class="markdownTableBodyLeft">PWM Compare Up Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07166">7166</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gabfc9a19e31d66f608b9008c8c0f31eb8" name="gabfc9a19e31d66f608b9008c8c0f31eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfc9a19e31d66f608b9008c8c0f31eb8">&#9670;&nbsp;</a></span>INTSTS <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t TIMER_T::INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md268"></a>
INTSTS</h1>
<h2><a class="anchor" id="autotoc_md269"></a>
Offset: 0x08  Timer0 Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TIF   </td><td class="markdownTableBodyLeft">Timer Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CNT value matches the CMPDAT value.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TWKF   </td><td class="markdownTableBodyLeft">Timer Wake-up Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the interrupt wake-up flag status of timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer does not cause CPU wake-up.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10423">10423</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gae7e9084b9945be30518cb97148eb78ea" name="gae7e9084b9945be30518cb97148eb78ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7e9084b9945be30518cb97148eb78ea">&#9670;&nbsp;</a></span>INTSTS <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md292"></a>
INTSTS</h1>
<h2><a class="anchor" id="autotoc_md293"></a>
Offset: 0x1C  UART Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RDAIF   </td><td class="markdownTableBodyLeft">Receive Data Available Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the number of bytes in the RX FIFO equals the RFITL(UART_FIFO[7:4]) then the RDAIF(UART_INTSTS[0]) will be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generate.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No RDA interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RDA interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL (UART_FIFO[7:4])).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">THREIF   </td><td class="markdownTableBodyLeft">Transmit Holding Register Empty Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If THREIEN (UART_INTEN [1]) is enabled, the THRE interrupt will be generate.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No THRE interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = THRE interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RLSIF   </td><td class="markdownTableBodyLeft">Receive Line Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generate.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No RLS interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RLS interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: In RS-485 function mode, this field is set including "receiver detects and receives address byte character (bit 9 = 1) bit".    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">At the same time, the bit of ADDRDETF (UART_FIFOSTS[3]) is also set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Only Available in UART0).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF (UART_FIFOSTS[5]), PEF (UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Only Available in UART0).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">MODEMIF   </td><td class="markdownTableBodyLeft">MODEM Interrupt Flag (Read Only) (Only Available In UART0)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the CTS pin has state change (CTSDETF (UART_MODEMSTS[0]) = 1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If MODEMIEN (UART_INTEN[3]) is enabled, the Modem interrupt will be generate.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Modem interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Modem interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only and reset to 0 when bit CTSDETF (UART_MODEMSTS[0]) is cleared by a write 1 on CTSDETF (UART_MODEMSTS[0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">RXTOIF   </td><td class="markdownTableBodyLeft">Time-out Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UARTTOUT[7:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If RXTOIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generate.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Time-out interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time-out interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">BUFERRIF   </td><td class="markdownTableBodyLeft">Buffer Error Interrupt Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set when the TX/RX FIFO overflow flag (TXOVIF (UART_FIFOSTS[24]) or RXOVIF(UART_FIFOSTS[0])) is set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When BUFERRIF (UART_INTSTS[5]) is set, the transfer is not correct.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If BUFERRIEN (UART_INTEN[5]) is enabled, the buffer error interrupt will be generate.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No buffer error interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Buffer error interrupt flag is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only and reset to 0 when all bits of TXOVIF (UART_FIFOSTS[24]) and RXOVIF (UART_FIFOSTS[0]) are cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">RDAINT   </td><td class="markdownTableBodyLeft">Receive Data Available Interrupt Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set if RDAIEN (UART_INTEN[0]) and RDAIF (UART_INTSTS[0]) are both set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No RDA interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RDA interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">THREINT   </td><td class="markdownTableBodyLeft">Transmit Holding Register Empty Interrupt Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set if THREIEN (UART_INTEN[1]) and THREIF (UART_INTSTS[1]) are both set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No THRE interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = THRE interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">RLSINT   </td><td class="markdownTableBodyLeft">Receive Line Status Interrupt (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set if RLSIEN (UART_INTEN[2]) and RLSIF (UART_INTSTS[2]) are both set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No RLS interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RLS interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">MODEMINT   </td><td class="markdownTableBodyLeft">MODEM Status Interrupt Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set if MODEMIEN (UART_INTEN[3]) and MODENIF (UART_INTSTS[3]) are both set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Modem interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Modem interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">RXTOINT   </td><td class="markdownTableBodyLeft">Time-out Interrupt Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set if RXTOIEN (UART_INTEN[4]) and RXTOIF (UART_INTSTS[4]) are both set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No Time-out interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time-out interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">BUFERRINT   </td><td class="markdownTableBodyLeft">Buffer Error Interrupt Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set if BUFERRIEN (UART_INTEN[5]) and BUFERRIF (UART_INTSTS[5]) are both set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No buffer error interrupt is generated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = buffer error interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">CTSWKIF   </td><td class="markdownTableBodyLeft">NCTS Wake-up Interrupt Flag (Read Only) (Only Available In UART0)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Chip stays in power-down state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Chip wake-up from power-down state by nCTS wake-up.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: If WKCTSIEN (UART_IER[9])is enabled, the wake-up interrupt is generated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This bit is read only, but can be cleared by writing '1' to it.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11049">11049</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2e1d37bb184d4c29c053078c22abec62" name="ga2e1d37bb184d4c29c053078c22abec62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e1d37bb184d4c29c053078c22abec62">&#9670;&nbsp;</a></span>INTTYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::INTTYPE</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md76"></a>
INTTYPE</h1>
<h2><a class="anchor" id="autotoc_md77"></a>
Offset: 0x18  P0 Interrupt Mode Control</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TYPE0   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge trigger interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Level trigger interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TYPE1   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge trigger interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Level trigger interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TYPE2   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge trigger interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Level trigger interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TYPE3   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge trigger interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Level trigger interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">TYPE4   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge trigger interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Level trigger interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">TYPE5   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge trigger interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Level trigger interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">TYPE6   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge trigger interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Level trigger interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">TYPE7   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Edge trigger interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Level trigger interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The de-bounce function is valid only for edge triggered interrupt.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the interrupt mode is level triggered, the de-bounce enable bit is ignore.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l02451">2451</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gabe3faafb786240ac95352ee0167f39d2" name="gabe3faafb786240ac95352ee0167f39d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe3faafb786240ac95352ee0167f39d2">&#9670;&nbsp;</a></span>IPRST0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IPRST0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md238"></a>
IPRST0</h1>
<h2><a class="anchor" id="autotoc_md239"></a>
Offset: 0x08  Peripheral Reset Control Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CHIPRST   </td><td class="markdownTableBodyLeft">CHIP One-shot Reset (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The CHIPRST is the same as the POR reset, all the chip controllers is reset and the chip settings from flash are also reload.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Chip normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CHIP one-shot reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is write protected. Refer to the SYS_REGLCTL register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">CPURST   </td><td class="markdownTableBodyLeft">Processor Core One-shot Reset (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will only reset the processor core and Flash Memory Controller (FMC), and this bit will automatically return to 0 after the 2 clock cycles.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Processor core normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Processor core one-shot reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is write protected. Refer to the SYS_REGLCTL register.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09545">9545</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga662c5e1c1f6c3ab1ffcde33b072115e9" name="ga662c5e1c1f6c3ab1ffcde33b072115e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga662c5e1c1f6c3ab1ffcde33b072115e9">&#9670;&nbsp;</a></span>IPRST1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IPRST1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md240"></a>
IPRST1</h1>
<h2><a class="anchor" id="autotoc_md241"></a>
Offset: 0x0C  Peripheral Reset Control Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">GPIORST   </td><td class="markdownTableBodyLeft">GPIO (P0~P5) Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = GPIO controller normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = GPIO controller reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TMR0RST   </td><td class="markdownTableBodyLeft">Timer0 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer0 controller normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer0 controller reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">TMR1RST   </td><td class="markdownTableBodyLeft">Timer1 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Timer1 controller normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Timer1 controller reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">I2C0RST   </td><td class="markdownTableBodyLeft">I2C0 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C0 controller normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C0 controller reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">I2C1RST   </td><td class="markdownTableBodyLeft">I2C1 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = I2C1 controller normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = I2C1 controller reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">SPI0RST   </td><td class="markdownTableBodyLeft">SPI0 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI controller normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI controller reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">UART0RST   </td><td class="markdownTableBodyLeft">UART0 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = UART0 controller normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = UART0 controller reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">UART1RST   </td><td class="markdownTableBodyLeft">UART1 Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = UART1 controller normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = UART1 controller reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">PWM0RST   </td><td class="markdownTableBodyLeft">PWM0 Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0 controller normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0 controller reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">ACMPRST   </td><td class="markdownTableBodyLeft">ACMP Controller Reset    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ACMP controller normal operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ACMP controller reset.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">ADCRST   </td><td class="markdownTableBodyLeft">ADC Controller Reset    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ADC controller normal operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ADC controller reset.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09588">9588</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaceb4afd6bca8d31adb2a95a132d8f333" name="gaceb4afd6bca8d31adb2a95a132d8f333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb4afd6bca8d31adb2a95a132d8f333">&#9670;&nbsp;</a></span>IRCTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IRCTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md256"></a>
IRCTCTL</h1>
<h2><a class="anchor" id="autotoc_md257"></a>
Offset: 0x80  HIRC Trim Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">FREQSEL   </td><td class="markdownTableBodyLeft">Trim Frequency Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is to enable the HIRC auto trim.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When setting this bit to 1, the HIRC auto trim function will trim HIRC to 22.1184 MHz automatically based on the LXT reference clock.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">During auto trim operation, if LXT clock error is detected or trim retry limitation count reached, this field will be cleared to 0 automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HIRC auto trim function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">LOOPSEL   </td><td class="markdownTableBodyLeft">Trim Calculation Loop    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field defines trim value calculation based on the number of LXT clock.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if LOOPSEL is set as "00", auto trim circuit will calculate trim value based on the average frequency difference in 4 LXT clocks.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field also defines how many times the auto trim circuit will try to update the HIRC trim value before the frequency of HIRC is locked.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once the HIRC is locked, the internal trim value update counter will be reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the trim value update counter reaches this limitation value and frequency of HIRC is still not locked, the auto trim operation will be disabled and FREQSEL will be cleared to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Trim value calculation is based on average difference in 4 LXT clock and trim retry count limitation is 64.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Trim value calculation is based on average difference in 8 LXT clock and trim retry count limitation is 128.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Trim value calculation is based on average difference in 16 LXT clock and trim retry count limitation is 256.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Trim value calculation is based on average difference in 32 LXT clock and trim retry count limitation is 512.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09974">9974</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga00a9989e7170001ca5890978cac52278" name="ga00a9989e7170001ca5890978cac52278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00a9989e7170001ca5890978cac52278">&#9670;&nbsp;</a></span>IRCTIEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IRCTIEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md258"></a>
IRCTIEN</h1>
<h2><a class="anchor" id="autotoc_md259"></a>
Offset: 0x84  HIRC Trim Interrupt Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TFAILIEN   </td><td class="markdownTableBodyLeft">Trim Failure Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if an interrupt will be triggered while HIRC trim value update limitation count is reached and HIRC frequency is still not locked on target frequency set by FREQSEL (SYS_IRCTCTL[1:0]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is high and TFAILIF (SYS_IRCTISTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count is reached.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TFAILIF (SYS_IRCTISTS[1]) status Disabled to trigger an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TFAILIF (SYS_IRCTISTS[1]) status Enabled to trigger an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CLKEIEN   </td><td class="markdownTableBodyLeft">LXT Clock Error Interrupt Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls if CPU could get an interrupt while LXT clock is inaccurate during auto trim operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is high, and CLKERRIF (SYS_IRCTISTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the LXT clock frequency is inaccurate.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CLKERRIF (SYS_IRCTISTS[2]) status Disabled to trigger an interrupt to CPU.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CLKERRIF (SYS_IRCTISTS[2]) status Enabled to trigger an interrupt to CPU.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09994">9994</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga43d51c3dfb45b714c7eefb9f1d789abc" name="ga43d51c3dfb45b714c7eefb9f1d789abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43d51c3dfb45b714c7eefb9f1d789abc">&#9670;&nbsp;</a></span>IRCTISTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::IRCTISTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md260"></a>
IRCTISTS</h1>
<h2><a class="anchor" id="autotoc_md261"></a>
Offset: 0x88  HIRC Trim Interrupt Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">FREQLOCK   </td><td class="markdownTableBodyLeft">HIRC Frequency Lock Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the HIRC frequency locked in 22.1184 MHz.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This is a read only status bit and doesn't trigger any interrupt.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TFAILIF   </td><td class="markdownTableBodyLeft">Trim Failure Interrupt Status    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates that HIRC trim value update limitation count reached and HIRC clock frequency still doesn't lock.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once this bit is set, the auto trim operation stopped and FREQSEL (SYS_IRCTCTL[1:0]) will be cleared to 0 by hardware automatically.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is set and TFAILIEN (SYS_IRCTIEN[1]) is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear this bit to .    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Trim value update limitation count is not reached.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Trim value update limitation count is reached and HIRC frequency is still not locked.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">CLKERRIF   </td><td class="markdownTableBodyLeft">LXT Clock Error Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates that LXT clock frequency is inaccuracy.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once this bit is set, the auto trim operation stopped and FREQSEL (SYS_IRCTCTL[0]) will be cleared to 0 by hardware automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If this bit is set and CLKEIEN (SYS_IRCTIEN[2]) is high, an interrupt will be triggered to notify the LXT clock frequency is inaccuracy.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can write 1 to clear this bit to .    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LXT clock frequency is accuracy.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LXT clock frequency is inaccuracy.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10021">10021</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0ea733efcc748349d58440f9e424e3ef" name="ga0ea733efcc748349d58440f9e424e3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ea733efcc748349d58440f9e424e3ef">&#9670;&nbsp;</a></span>IRDA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::IRDA</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md298"></a>
IRDA</h1>
<h2><a class="anchor" id="autotoc_md299"></a>
Offset: 0x28  UART IrDA Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TXEN   </td><td class="markdownTableBodyLeft">IrDA Receiver/Transmitter Selection Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IrDA Transmitter Disabled and Receiver Enabled. (Default)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IrDA Transmitter Enabled and Receiver Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">TXINV   </td><td class="markdownTableBodyLeft">IrDA Inverse Transmitting Output Signal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = None inverse transmitting signal. (Default)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverse transmitting output signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">RXINV   </td><td class="markdownTableBodyLeft">IrDA Inverse Receive Input Signal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = None inverse receiving input signal.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Inverse receiving input signal. (Default)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11111">11111</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga6d20872bf4fccaed7e88b19fb4a3a50c" name="ga6d20872bf4fccaed7e88b19fb4a3a50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d20872bf4fccaed7e88b19fb4a3a50c">&#9670;&nbsp;</a></span>IRQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t INTR_T::IRQ</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md156"></a>
IRQ</h1>
<h2><a class="anchor" id="autotoc_md157"></a>
Offset: 0x84  MCU IRQ Number Identity Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">MCU_IRQ   </td><td class="markdownTableBodyLeft">MCU IRQ Source Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0 core.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">There are two modes to generate interrupt to Cortex-M0 - the normal mode and test mod.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The MCU_IRQ collects all interrupts from each peripheral and synchronizes them then interrupts the Cortex-M0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the MCU_IRQ[n] is 0, setting MCU_IRQ[n] to 1 will generate an interrupt to Cortex-M0 NVIC[n].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the MCU_IRQ[n] is 1 (mean an interrupt is assert), setting 1 to the MCU_bit[n] will clear the interrupt and setting MCU_IRQ[n] 0 has no effect.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05278">5278</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga91fce36f79cd65f12f58e9651f6f09d2" name="ga91fce36f79cd65f12f58e9651f6f09d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91fce36f79cd65f12f58e9651f6f09d2">&#9670;&nbsp;</a></span>IRQ0_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ0_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md114"></a>
IRQ0_SRC</h1>
<h2><a class="anchor" id="autotoc_md115"></a>
Offset: 0x00  IRQ0 (BOD) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">BOD_INT   </td><td class="markdownTableBodyLeft">IRQ0 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ0 source is not from BOD interrupt (BOD_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ0 source is from BOD interrupt (BOD_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04970">4970</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga59dc58587d2617882d8f9ca77c13b4a2" name="ga59dc58587d2617882d8f9ca77c13b4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59dc58587d2617882d8f9ca77c13b4a2">&#9670;&nbsp;</a></span>IRQ12_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ12_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md134"></a>
IRQ12_SRC</h1>
<h2><a class="anchor" id="autotoc_md135"></a>
Offset: 0x30  IRQ12 (UART0) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">UART0_INT   </td><td class="markdownTableBodyLeft">IRQ12 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ12 source is not from UART0 interrupt (UART0_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ12 source is from UART0 interrupt (UART0_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05116">5116</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga51d308fe67c335bdcf181f53fe632acd" name="ga51d308fe67c335bdcf181f53fe632acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51d308fe67c335bdcf181f53fe632acd">&#9670;&nbsp;</a></span>IRQ13_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ13_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md136"></a>
IRQ13_SRC</h1>
<h2><a class="anchor" id="autotoc_md137"></a>
Offset: 0x34  IRQ13 (UART1) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">UART1_INT   </td><td class="markdownTableBodyLeft">IRQ13 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ13 source is not from UART1 interrupt (UART1_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ13 source is from UART1 interrupt (UART1_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05129">5129</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga869bfad4f8041ab28dad45ff023ebbcb" name="ga869bfad4f8041ab28dad45ff023ebbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga869bfad4f8041ab28dad45ff023ebbcb">&#9670;&nbsp;</a></span>IRQ14_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ14_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md138"></a>
IRQ14_SRC</h1>
<h2><a class="anchor" id="autotoc_md139"></a>
Offset: 0x38  IRQ14 (SPI) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">SPI_INT   </td><td class="markdownTableBodyLeft">IRQ14 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ14 source is not from SPI interrupt (SPI_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ14 source is from SPI interrupt (SPI_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05142">5142</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaeecdba956413b453f66d69ab6b127d9e" name="gaeecdba956413b453f66d69ab6b127d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeecdba956413b453f66d69ab6b127d9e">&#9670;&nbsp;</a></span>IRQ16_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ16_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md140"></a>
IRQ16_SRC</h1>
<h2><a class="anchor" id="autotoc_md141"></a>
Offset: 0x40  IRQ16 (GP5) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GP5_INT   </td><td class="markdownTableBodyLeft">IRQ16 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ16 source is not from GP5 interrupt (GP5_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ16 source is from GP5 interrupt (GP5_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05159">5159</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaaf45dfdd7b47098231d839313057e835" name="gaaf45dfdd7b47098231d839313057e835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf45dfdd7b47098231d839313057e835">&#9670;&nbsp;</a></span>IRQ17_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ17_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md142"></a>
IRQ17_SRC</h1>
<h2><a class="anchor" id="autotoc_md143"></a>
Offset: 0x44  IRQ17 (HIRC trim) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">HIRC_TRIM_INT   </td><td class="markdownTableBodyLeft">IRQ17 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ17 source is not from HIRC trim interrupt (HIRC_TRIM_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ17 source is from HIRC trim interrupt (HIRC_TRIM_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05172">5172</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0639942505016e78cd35be5bb550771f" name="ga0639942505016e78cd35be5bb550771f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0639942505016e78cd35be5bb550771f">&#9670;&nbsp;</a></span>IRQ18_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ18_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md144"></a>
IRQ18_SRC</h1>
<h2><a class="anchor" id="autotoc_md145"></a>
Offset: 0x48  IRQ18 (I2C0) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">I2C0_INT   </td><td class="markdownTableBodyLeft">IRQ18 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ18 source is not from I2C0 interrupt (I2C0_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ18 source is from I2C0 interrupt (I2C0_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05185">5185</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga3be0458e7fe6f6ccaf232c55d3b8f4e5" name="ga3be0458e7fe6f6ccaf232c55d3b8f4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3be0458e7fe6f6ccaf232c55d3b8f4e5">&#9670;&nbsp;</a></span>IRQ19_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ19_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md146"></a>
IRQ19_SRC</h1>
<h2><a class="anchor" id="autotoc_md147"></a>
Offset: 0x4C  IRQ19 (I2C1) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">I2C1_INT   </td><td class="markdownTableBodyLeft">IRQ19 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ19 source is not from I2C1 interrupt (I2C1_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ19 source is from I2C1 interrupt (I2C1_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05198">5198</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga7b7e99f775e86b07b2ba28727dde1961" name="ga7b7e99f775e86b07b2ba28727dde1961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b7e99f775e86b07b2ba28727dde1961">&#9670;&nbsp;</a></span>IRQ1_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ1_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md116"></a>
IRQ1_SRC</h1>
<h2><a class="anchor" id="autotoc_md117"></a>
Offset: 0x04  IRQ1 (WDT) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WDT_INT   </td><td class="markdownTableBodyLeft">IRQ1 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ1 source is not from watchdog interrupt (WDT _INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ1 source is from watchdog interrupt (WDT_INT).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">WWDT_INT   </td><td class="markdownTableBodyLeft">IRQ1 Source Identity    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ1 source is not from window watchdog interrupt (WWDT _INT).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ1 source is from window watchdog interrupt (WWDT_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04986">4986</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gac8be0f656d0b4c98d4c1571344cf0a2e" name="gac8be0f656d0b4c98d4c1571344cf0a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8be0f656d0b4c98d4c1571344cf0a2e">&#9670;&nbsp;</a></span>IRQ25_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ25_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md148"></a>
IRQ25_SRC</h1>
<h2><a class="anchor" id="autotoc_md149"></a>
Offset: 0x64  IRQ25 (ACMP) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ACMP_INT   </td><td class="markdownTableBodyLeft">IRQ25 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ25 source is not from ACMP interrupt (ACMP_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ25 source is from ACMP interrupt (ACMP_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05215">5215</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0074102f9939059ab1daf7361ec5b75d" name="ga0074102f9939059ab1daf7361ec5b75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0074102f9939059ab1daf7361ec5b75d">&#9670;&nbsp;</a></span>IRQ28_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ28_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md150"></a>
IRQ28_SRC</h1>
<h2><a class="anchor" id="autotoc_md151"></a>
Offset: 0x70  IRQ28 (PWRWU) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">PWRWU_INT   </td><td class="markdownTableBodyLeft">IRQ28 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ28 source is not from PWRWU interrupt (PWRWU_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ28 source is from PWREU interrupt (PWRWU_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05232">5232</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gae3553f04c068483737218a748e6e4cba" name="gae3553f04c068483737218a748e6e4cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3553f04c068483737218a748e6e4cba">&#9670;&nbsp;</a></span>IRQ29_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ29_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md152"></a>
IRQ29_SRC</h1>
<h2><a class="anchor" id="autotoc_md153"></a>
Offset: 0x74  IRQ29 (ADC) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ADC_INT   </td><td class="markdownTableBodyLeft">IRQ29 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ29 source is not from ADC interrupt (ADC_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ29 source is from ADC interrupt (ADC_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05245">5245</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga310daef4f69c58d2cdc6d292b51a982f" name="ga310daef4f69c58d2cdc6d292b51a982f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga310daef4f69c58d2cdc6d292b51a982f">&#9670;&nbsp;</a></span>IRQ2_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ2_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md118"></a>
IRQ2_SRC</h1>
<h2><a class="anchor" id="autotoc_md119"></a>
Offset: 0x08  IRQ2 (EINT0) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">EINT0   </td><td class="markdownTableBodyLeft">IRQ2 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ2 source is not from external signal interrupt 0 from P3.2 (EINT0).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ2 source is from external signal interrupt 0 from P3.2 (EINT0).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04999">4999</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gac37b01494b3e644ad8bd85caa40af0df" name="gac37b01494b3e644ad8bd85caa40af0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac37b01494b3e644ad8bd85caa40af0df">&#9670;&nbsp;</a></span>IRQ3_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ3_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md120"></a>
IRQ3_SRC</h1>
<h2><a class="anchor" id="autotoc_md121"></a>
Offset: 0x0C  IRQ3 (EINT1) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">EINT1   </td><td class="markdownTableBodyLeft">IRQ3 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ3 source is not from external signal interrupt 1 from P5.2 (EINT1).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ3 source is from external signal interrupt 1 from P5.2 (EINT1).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05012">5012</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga47be980853ed88f61819d0e82c639809" name="ga47be980853ed88f61819d0e82c639809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47be980853ed88f61819d0e82c639809">&#9670;&nbsp;</a></span>IRQ4_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ4_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md122"></a>
IRQ4_SRC</h1>
<h2><a class="anchor" id="autotoc_md123"></a>
Offset: 0x10  IRQ4 (GP0/1) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GP0_INT   </td><td class="markdownTableBodyLeft">IRQ4 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ4 source is not from GP0 interrupt (GP0_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ4 source is from GP0 interrupt (GP0_INT).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">GP1_INT   </td><td class="markdownTableBodyLeft">IRQ4 Source Identity    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ4 source is not from GP1 interrupt (GP1_INT).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ4 source is from GP1 interrupt (GP1_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05028">5028</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga7d89b8973976a13d75c7e90f4ef79a9a" name="ga7d89b8973976a13d75c7e90f4ef79a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d89b8973976a13d75c7e90f4ef79a9a">&#9670;&nbsp;</a></span>IRQ5_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ5_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md124"></a>
IRQ5_SRC</h1>
<h2><a class="anchor" id="autotoc_md125"></a>
Offset: 0x14  IRQ5 (GP2/3/4) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">GP2_INT   </td><td class="markdownTableBodyLeft">IRQ5 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ5 source is not from GP2 interrupt (GP2_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ5 source is from GP2 interrupt (GP2_INT).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">GP3_INT   </td><td class="markdownTableBodyLeft">IRQ5 Source Identity    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ5 source is not from GP3 interrupt (GP3_INT).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ5 source is from GP3 interrupt (GP3_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">GP4_INT   </td><td class="markdownTableBodyLeft">IRQ5 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ5 source is not from GP4 interrupt (GP4_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ5 source is from GP4 interrupt (GP4_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05047">5047</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga6a77cbbb6a3e73a3f7edae83ea1965ba" name="ga6a77cbbb6a3e73a3f7edae83ea1965ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a77cbbb6a3e73a3f7edae83ea1965ba">&#9670;&nbsp;</a></span>IRQ6_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ6_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md126"></a>
IRQ6_SRC</h1>
<h2><a class="anchor" id="autotoc_md127"></a>
Offset: 0x18  IRQ6 (PWM) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">PWM_INT   </td><td class="markdownTableBodyLeft">IRQ6 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ6 source is not from PWM interrupt (PWM_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ6 source is from PWM interrupt (PWM_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05060">5060</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga4b3b2d0c8c58af07f8a2c41f50b11643" name="ga4b3b2d0c8c58af07f8a2c41f50b11643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b3b2d0c8c58af07f8a2c41f50b11643">&#9670;&nbsp;</a></span>IRQ7_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ7_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md128"></a>
IRQ7_SRC</h1>
<h2><a class="anchor" id="autotoc_md129"></a>
Offset: 0x1C  IRQ7 (BRAKE) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">BRAKE_INT   </td><td class="markdownTableBodyLeft">IRQ7 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ7 source is not from Brake interrupt (BRAKE_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ7 source is from Brake interrupt (BRAKE_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05073">5073</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0a8f99a682a9e1b4d2e5e941b377505b" name="ga0a8f99a682a9e1b4d2e5e941b377505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a8f99a682a9e1b4d2e5e941b377505b">&#9670;&nbsp;</a></span>IRQ8_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ8_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md130"></a>
IRQ8_SRC</h1>
<h2><a class="anchor" id="autotoc_md131"></a>
Offset: 0x20  IRQ8 (TMR0) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TMR0_INT   </td><td class="markdownTableBodyLeft">IRQ8 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ8 source is not from Timer0 interrupt (TMR0_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ8 source is from Timer0 interrupt (TMR0_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05086">5086</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gacb1b7434688d5f24efc282ec7271973a" name="gacb1b7434688d5f24efc282ec7271973a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb1b7434688d5f24efc282ec7271973a">&#9670;&nbsp;</a></span>IRQ9_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t INTR_T::IRQ9_SRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md132"></a>
IRQ9_SRC</h1>
<h2><a class="anchor" id="autotoc_md133"></a>
Offset: 0x24  IRQ9 (TMR1) Interrupt Source Identity</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TMR1_INT   </td><td class="markdownTableBodyLeft">IRQ9 Source Identity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = IRQ9 source is not from Timer1 interrupt (TMR1_INT).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = IRQ9 source is from Timer1 interrupt (TMR1_INT).   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05099">5099</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga3e74a55963b3f93f231054dc940a5be3" name="ga3e74a55963b3f93f231054dc940a5be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e74a55963b3f93f231054dc940a5be3">&#9670;&nbsp;</a></span>ISPADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPADDR</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md50"></a>
ISPADDR</h1>
<h2><a class="anchor" id="autotoc_md51"></a>
Offset: 0x04  ISP Address Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">ISPADDR   </td><td class="markdownTableBodyLeft">ISP Address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Mini58 series is equipped with embedded flash.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ISPADDR[1:0] must be kept 00 for ISP 32-bit operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">and ISPADR[8:0] must be kept all 0 for Vector Page Re-map Command.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For CRC32 Checksum Calculation command, this field is the flash starting address for checksum calculation, 512 bytes alignment is necessary for checksum calculation.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01409">1409</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga535eb6e9457c338ac7515a5d2ff06802" name="ga535eb6e9457c338ac7515a5d2ff06802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535eb6e9457c338ac7515a5d2ff06802">&#9670;&nbsp;</a></span>ISPCMD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPCMD</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md54"></a>
ISPCMD</h1>
<h2><a class="anchor" id="autotoc_md55"></a>
Offset: 0x0C  ISP Command Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6:0]   </td><td class="markdownTableBodyCenter">CMD   </td><td class="markdownTableBodyLeft">ISP CMD    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ISP command table is shown below:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x00= FLASH Read.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x04= Read Unique ID.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x0B= Read Company ID.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x0C= Read Device ID.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x0D= Read CRC32 Checksum.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x21= FLASH 32-bit Program.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x22= FLASH Page Erase.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x2D= Run CRC32 Checksum Calculation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0x2E= Vector Remap.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The other commands are invalid.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01447">1447</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0599b0536ac7829ab7370046511eb94c" name="ga0599b0536ac7829ab7370046511eb94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0599b0536ac7829ab7370046511eb94c">&#9670;&nbsp;</a></span>ISPCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md48"></a>
ISPCTL</h1>
<h2><a class="anchor" id="autotoc_md49"></a>
Offset: 0x00  ISP Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ISPEN   </td><td class="markdownTableBodyLeft">ISP Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this bit to enable the ISP function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ISP function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ISP function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">BS   </td><td class="markdownTableBodyLeft">Boot Select (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set/clear this bit to select next booting from LDROM/APROM, respectively.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit also functions as chip booting status flag, which can be used to check where chip booted from.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is initiated with the inversed value of CBS[1] (CONFIG0[7]) after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Booting from APROM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Booting from LDROM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">SPUEN   </td><td class="markdownTableBodyLeft">SPROM Update Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPROM cannot be updated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPROM can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">APUEN   </td><td class="markdownTableBodyLeft">APROM Update Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = APROM cannot be updated when the chip runs in APROM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = APROM can be updated when the chip runs in APROM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CFGUEN   </td><td class="markdownTableBodyLeft">CONFIG Update Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CONFIG cannot be updated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CONFIG can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">LDUEN   </td><td class="markdownTableBodyLeft">LDROM Update Enable (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">LDROM update enable bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LDROM cannot be updated.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LDROM can be updated.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">ISPFF   </td><td class="markdownTableBodyLeft">ISP Fail Flag (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when a triggered ISP meets any of the following conditions:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit needs to be cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1) APROM writes to itself if APUEN is set to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(2) LDROM writes to itself if LDUEN is set to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(3) CONFIG is erased/programmed if CFGUEN is set to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(4) SPROM is erased/programmed if SPUEN is set to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(5) SPROM is programmed at SPROM secured mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(6) Page Erase command at LOCK mode with ICE connection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(7) Erase or Program command at brown-out detected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(8) Destination address is illegal, such as over an available range.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(9) Invalid ISP commands.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01394">1394</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga93a594f096446ee933113f6c57c200c3" name="ga93a594f096446ee933113f6c57c200c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93a594f096446ee933113f6c57c200c3">&#9670;&nbsp;</a></span>ISPDAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPDAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md52"></a>
ISPDAT</h1>
<h2><a class="anchor" id="autotoc_md53"></a>
Offset: 0x08  ISP Data Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">ISPDAT   </td><td class="markdownTableBodyLeft">ISP Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write data to this register before ISP program operation.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Read data from this register after ISP read operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For Run CRC32 Checksum Calculation command, ISPDAT is the memory size (byte) and 512 bytes alignment.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For ISP Read Checksum command, ISPDAT is the checksum result.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If ISPDAT = 0x0000_0000, it means that (1) the checksum calculation is in progress, or (2) the memory range for checksum calculation is incorrect.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01425">1425</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga84712a01970a90ae3f2526fc53cb1998" name="ga84712a01970a90ae3f2526fc53cb1998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84712a01970a90ae3f2526fc53cb1998">&#9670;&nbsp;</a></span>ISPSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t FMC_T::ISPSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md62"></a>
ISPSTS</h1>
<h2><a class="anchor" id="autotoc_md63"></a>
Offset: 0x40  ISP Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ISPBUSY   </td><td class="markdownTableBodyLeft">ISP BUSY (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ISP operation is finished.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ISP operation is busy.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2:1]   </td><td class="markdownTableBodyCenter">CBS   </td><td class="markdownTableBodyLeft">Boot Selection Of CONFIG (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is initiated with the CBS (CONFIG0[7:6]) after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = LDROM with IAP mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = LDROM without IAP mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = APROM with IAP mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = APROM without IAP mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">ISPFF   </td><td class="markdownTableBodyLeft">ISP Fail Flag (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when a triggered ISP meets any of the following conditions:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1) APROM writes to itself if APUEN is set to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(2) LDROM writes to itself if LDUEN is set to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(3) CONFIG is erased/programmed if CFGUEN is set to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(4) SPROM is erased/programmed if SPUEN is set to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(5) SPROM is programmed at SPROM secured mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(6) Page Erase command at LOCK mode with ICE connection.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(7) Erase or Program command at brown-out detected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(8) Destination address is illegal, such as over an available range.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(9) Invalid ISP commands.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20:9]   </td><td class="markdownTableBodyCenter">VECMAP   </td><td class="markdownTableBodyLeft">Vector Page Mapping Address (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">All access to 0x0000_0000~0x0000_01FF is remapped to the flash memory address {VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">SCODE   </td><td class="markdownTableBodyLeft">Security Code Active Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to 1 by hardware when detecting SPROM secured code is active at flash initialization, or software writes 1 to this bit to make secured code active; this bit is only cleared by SPROM page erase operation.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPROM secured code is inactive.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPROM secured code is active.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01530">1530</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaef7c67979c87346e1de844a30b649269" name="gaef7c67979c87346e1de844a30b649269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef7c67979c87346e1de844a30b649269">&#9670;&nbsp;</a></span>ISPTRG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t FMC_T::ISPTRG</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md56"></a>
ISPTRG</h1>
<h2><a class="anchor" id="autotoc_md57"></a>
Offset: 0x10  ISP Trigger Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ISPGO   </td><td class="markdownTableBodyLeft">ISP Start Trigger (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ISP operation is finished.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ISP is progressed.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01461">1461</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga374e1f1945b9df2e8e2a582729b07d99" name="ga374e1f1945b9df2e8e2a582729b07d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga374e1f1945b9df2e8e2a582729b07d99">&#9670;&nbsp;</a></span>LINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::LINE</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md284"></a>
LINE</h1>
<h2><a class="anchor" id="autotoc_md285"></a>
Offset: 0x0C  UART Line Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">WLS   </td><td class="markdownTableBodyLeft">Word Length Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Word length is 5-bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Word length is 6-bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Word length is 7-bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Word length is 8-bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">NSB   </td><td class="markdownTableBodyLeft">Number of "STOP Bit"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = One "STOP bit" is generated in the transmitted data.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">PBE   </td><td class="markdownTableBodyLeft">Parity Bit Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No parity bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Parity bit is generated on each outgoing character and is checked on each incoming data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">EPE   </td><td class="markdownTableBodyLeft">Even Parity Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Odd number of logic 1's is transmitted and checked in each word.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Even number of logic 1's is transmitted and checked in each word.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit has effect only when PBE (UART_LINE[3]) is set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">SPE   </td><td class="markdownTableBodyLeft">Stick Parity Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Stick parity Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as .    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">BCB   </td><td class="markdownTableBodyLeft">Break Control Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit acts only on TX and has no effect on the transmitter logic.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Break control Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Break control Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10837">10837</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gae04592bd9239c0732eb62847d146209f" name="gae04592bd9239c0732eb62847d146209f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae04592bd9239c0732eb62847d146209f">&#9670;&nbsp;</a></span>MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t GPIO_T::MODE</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md64"></a>
MODE</h1>
<h2><a class="anchor" id="autotoc_md65"></a>
Offset: 0x00  P0 I/O Mode Control</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">MODE0   </td><td class="markdownTableBodyLeft">Port 0-5 I/O Pin[N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine each I/O mode of Px.n pins.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Px.n is in Input mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Px.n is in Push-pull Output mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Px.n is in Open-drain Output mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Px.n is in Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The initial value of this field is defined by CIOINI (Config0[10]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">input mode after chip powered on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">MODE1   </td><td class="markdownTableBodyLeft">Port 0-5 I/O Pin[N] Mode Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine each I/O mode of Px.n pins.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Px.n is in Input mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Px.n is in Push-pull Output mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Px.n is in Open-drain Output mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Px.n is in Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The initial value of this field is defined by CIOINI (Config0[10]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">input mode after chip powered on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:4]   </td><td class="markdownTableBodyCenter">MODE2   </td><td class="markdownTableBodyLeft">Port 0-5 I/O Pin[N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine each I/O mode of Px.n pins.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Px.n is in Input mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Px.n is in Push-pull Output mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Px.n is in Open-drain Output mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Px.n is in Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The initial value of this field is defined by CIOINI (Config0[10]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">input mode after chip powered on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7:6]   </td><td class="markdownTableBodyCenter">MODE3   </td><td class="markdownTableBodyLeft">Port 0-5 I/O Pin[N] Mode Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine each I/O mode of Px.n pins.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Px.n is in Input mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Px.n is in Push-pull Output mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Px.n is in Open-drain Output mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Px.n is in Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The initial value of this field is defined by CIOINI (Config0[10]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">input mode after chip powered on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9:8]   </td><td class="markdownTableBodyCenter">MODE4   </td><td class="markdownTableBodyLeft">Port 0-5 I/O Pin[N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine each I/O mode of Px.n pins.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Px.n is in Input mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Px.n is in Push-pull Output mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Px.n is in Open-drain Output mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Px.n is in Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The initial value of this field is defined by CIOINI (Config0[10]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">input mode after chip powered on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11:10]   </td><td class="markdownTableBodyCenter">MODE5   </td><td class="markdownTableBodyLeft">Port 0-5 I/O Pin[N] Mode Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine each I/O mode of Px.n pins.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Px.n is in Input mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Px.n is in Push-pull Output mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Px.n is in Open-drain Output mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Px.n is in Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The initial value of this field is defined by CIOINI (Config0[10]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">input mode after chip powered on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:12]   </td><td class="markdownTableBodyCenter">MODE6   </td><td class="markdownTableBodyLeft">Port 0-5 I/O Pin[N] Mode Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine each I/O mode of Px.n pins.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Px.n is in Input mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Px.n is in Push-pull Output mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Px.n is in Open-drain Output mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Px.n is in Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The initial value of this field is defined by CIOINI (Config0[10]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">input mode after chip powered on.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15:14]   </td><td class="markdownTableBodyCenter">MODE7   </td><td class="markdownTableBodyLeft">Port 0-5 I/O Pin[N] Mode Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Determine each I/O mode of Px.n pins.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Px.n is in Input mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Px.n is in Push-pull Output mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Px.n is in Open-drain Output mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Px.n is in Quasi-bidirectional mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: The initial value of this field is defined by CIOINI (Config0[10]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">input mode after chip powered on.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01751">1751</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaafa1ead360982a4a7e1ad1c372584fe1" name="gaafa1ead360982a4a7e1ad1c372584fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa1ead360982a4a7e1ad1c372584fe1">&#9670;&nbsp;</a></span>MODEM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::MODEM</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md286"></a>
MODEM</h1>
<h2><a class="anchor" id="autotoc_md287"></a>
Offset: 0x10  UART Modem Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">RTS   </td><td class="markdownTableBodyLeft">RTS (Request-to-send) Signal Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is direct control internal RTS signal active or not, and then drive the RTS pin output with RTSACTLV bit configuration.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTS signal is active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTS signal is inactive.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">RTSACTLV   </td><td class="markdownTableBodyLeft">RTS Pin Active Level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit defines the active level state of RTS pin output.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTS pin output is high level active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTS pin output is low level active. (Default)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note1: Refer to Figure 6.10-13 and Figure 6.10-14 UART function mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note2: Refer to Figure 6.10-17 and Figure 6.10-18 for RS-485 function mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">RTSSTS   </td><td class="markdownTableBodyLeft">RTS Pin State (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit mirror from RTS pin output of voltage logic status.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = RTS pin output is low level voltage logic state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = RTS pin output is high level voltage logic state.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10863">10863</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2b4d0fc0b816b782c91353cbd62fac73" name="ga2b4d0fc0b816b782c91353cbd62fac73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b4d0fc0b816b782c91353cbd62fac73">&#9670;&nbsp;</a></span>MODEMSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::MODEMSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md288"></a>
MODEMSTS</h1>
<h2><a class="anchor" id="autotoc_md289"></a>
Offset: 0x14  UART Modem Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">CTSDETF   </td><td class="markdownTableBodyLeft">Detect CTS State Change Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN [3]) is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CTS input has not change state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CTS input has change state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">CTSSTS   </td><td class="markdownTableBodyLeft">CTS Pin Status (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit mirror from CTS pin input of voltage logic status.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CTS pin input is low level voltage logic state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CTS pin input is high level voltage logic state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CTSACTLV   </td><td class="markdownTableBodyLeft">CTS Pin Active Level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit defines the active level state of CTS pin input.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = CTS pin input is high level active.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = CTS pin input is low level active. (Default)   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10887">10887</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gafdd26661e05de9c177033c429c351d4b" name="gafdd26661e05de9c177033c429c351d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdd26661e05de9c177033c429c351d4b">&#9670;&nbsp;</a></span>MSKALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::MSKALIGN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md216"></a>
MSKALIGN</h1>
<h2><a class="anchor" id="autotoc_md217"></a>
Offset: 0x8C  PWM Phase Change Mask Aligned Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT0   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT1   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT2   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT3   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT4   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT5   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN0   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN1   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN2   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN3   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN4   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN5   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:16]   </td><td class="markdownTableBodyCenter">ALIGNn   </td><td class="markdownTableBodyLeft">PWM0_CHn Output Mask Aligned Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output will mask immediately when mask function enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output will mask when output aligned to PWM period.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07890">7890</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8dcd32bdbde53be1c208b7171e05a25d" name="ga8dcd32bdbde53be1c208b7171e05a25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dcd32bdbde53be1c208b7171e05a25d">&#9670;&nbsp;</a></span>P0_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::P0_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md244"></a>
P0_MFP</h1>
<h2><a class="anchor" id="autotoc_md245"></a>
Offset: 0x30  P0 Multiple Function and Input Type Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">MFP   </td><td class="markdownTableBodyLeft">P0 Multiple Function Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The pin function of P0 depends on MFP and ALT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to ALT Description for details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">ALT0   </td><td class="markdownTableBodyLeft">P0.0 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[0] (SYS_P0_MFP[8]), and MFP[0] (SYS_P0_MFP[0]) determine the P0.0 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = UART0_nCTS function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = UART0_TXD function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">ALT1   </td><td class="markdownTableBodyLeft">P0.1 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[1] (SYS_P0_MFP[9]), and MFP[1] (SYS_P0_MFP[1]) determine the P0.1 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = SPI0_SS function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = UART0_nRTS function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = UART0_RXD function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">ALT4   </td><td class="markdownTableBodyLeft">P0.4 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[4] (SYS_P0_MFP[12]), and MFP[4] (SYS_P0_MFP[4]) determine the P0.4 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = SPI0_SS function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = PWM0_CH5 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">ALT5   </td><td class="markdownTableBodyLeft">P0.5 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[5] (SYS_P0_MFP[13]), and MFP[5] (SYS_P0_MFP[5]) determine the P0.5 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = SPI0_MOSI function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = PWM0_CH4 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">ALT6   </td><td class="markdownTableBodyLeft">P0.6 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[6] (SYS_P0_MFP[14]), and MFP[6] (SYS_P0_MFP[6]) determine the P0.6 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = SPI0_MISO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = PWM0_CH1 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">ALT7   </td><td class="markdownTableBodyLeft">P0.7 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[7] (SYS_P0_MFP[15]), and MFP[7] (SYS_P0_MFP[7]) determine the P0.7 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = SPI0_CLK function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = PWM0_CH0 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">TYPE   </td><td class="markdownTableBodyLeft">P0[7:0] Input Schmitt Trigger Function Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = P0[7:0] I/O input Schmitt Trigger function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = P0[7:0] I/O input Schmitt Trigger function Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09690">9690</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gae0e49256798068ee1ddb329a6c6eea1e" name="gae0e49256798068ee1ddb329a6c6eea1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0e49256798068ee1ddb329a6c6eea1e">&#9670;&nbsp;</a></span>P1_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::P1_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md246"></a>
P1_MFP</h1>
<h2><a class="anchor" id="autotoc_md247"></a>
Offset: 0x34  P1 Multiple Function and Input Type Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">MFP   </td><td class="markdownTableBodyLeft">P1 Multiple Function Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The pin function of P1 depends on MFP and ALT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to ALT Description for details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">ALT0   </td><td class="markdownTableBodyLeft">P1.0 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[0] (SYS_P1_MFP[8]), and MFP[0] (SYS_P1_MFP[0]) determine the P1.0 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = ADC_CH1 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = ACMP0_P1 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">ALT2   </td><td class="markdownTableBodyLeft">P1.2 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits P12EXT (SYS_P1_MFP[26]), ALT[2] (SYS_P1_MFP[10]), and MFP[2] (SYS_P1_MFP[2]) determine the P1.2 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 1) = ADC_CH2 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 0) = UART0_RXD function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 1) = ACMP0_P2 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0, 0) = PWM0_CH0 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">ALT3   </td><td class="markdownTableBodyLeft">P1.3 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits P13EXT (SYS_P1_MFP[27]), ALT[3] (SYS_P1_MFP[11]), and MFP[3] (SYS_P1_MFP[3]) determine the P1.3 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 1) = ADC_CH3 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 0) = UART0_TXD function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 1) = ACMP0_P3 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0, 0) = PWM0_CH1 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">ALT4   </td><td class="markdownTableBodyLeft">P1.4 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits P14EXT (SYS_P1_MFP[28]), ALT[4] (SYS_P1_MFP[12]), and MFP[4] (SYS_P1_MFP[4]) determine the P1.4 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 1) = ADC_CH4 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 0) = UART1_RXD function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 1) = ACMP0_N function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0, 0) = PWM0_CH4 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">ALT5   </td><td class="markdownTableBodyLeft">P1.5 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[5] (SYS_P1_MFP[13]), and MFP[5] (SYS_P1_MFP[5]) determine the P1.5 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = ADC_CH5 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = UART1_TXD function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = ACMP0_P0 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">TYPE   </td><td class="markdownTableBodyLeft">P1[7:0] Input Schmitt Trigger Function Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = P1[7:0] I/O input Schmitt Trigger function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = P1[7:0] I/O input Schmitt Trigger function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">P12EXT   </td><td class="markdownTableBodyLeft">P1.2 Alternate Function Selection Extension    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits P12EXT (SYS_P1_MFP[26]), ALT[2] (SYS_P1_MFP[10]), and MFP[2] (SYS_P1_MFP[2]) determine the P1.2 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 1) = ADC_CH2 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 0) = UART0_RXD function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 1) = ACMP0_P2 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0, 0) = PWM0_CH0 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">P13EXT   </td><td class="markdownTableBodyLeft">P1.3 Alternate Function Selection Extension    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits P13EXT (SYS_P1_MFP[27]), ALT[3] (SYS_P1_MFP[11]), and MFP[3] (SYS_P1_MFP[3]) determine the P1.3 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 1) = ADC_CH3 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 0) = UART0_TXD function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 1) = ACMP0_P3 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0, 0) = PWM0_CH1 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[28]   </td><td class="markdownTableBodyCenter">P14EXT   </td><td class="markdownTableBodyLeft">P1.4 Alternate Function Selection Extension    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits P14EXT (SYS_P1_MFP[28]), ALT[4] (SYS_P1_MFP[12]), and MFP[4] (SYS_P1_MFP[4]) determine the P1.4 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 1) = ADC_CH4 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 0) = UART1_RXD function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 1) = ACMP0_N function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0, 0) = PWM0_CH4 function is selected.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09760">9760</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga09d2fa8ba015afa226505d64b0a7aa4c" name="ga09d2fa8ba015afa226505d64b0a7aa4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d2fa8ba015afa226505d64b0a7aa4c">&#9670;&nbsp;</a></span>P2_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::P2_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md248"></a>
P2_MFP</h1>
<h2><a class="anchor" id="autotoc_md249"></a>
Offset: 0x38  P2 Multiple Function and Input Type Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">MFP   </td><td class="markdownTableBodyLeft">P2 Multiple Function Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The pin function of P2 depends on MFP and ALT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to ALT Description for details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">ALT2   </td><td class="markdownTableBodyLeft">P2.2 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[2] (SYS_P2_MFP[10]), and MFP[2] (SYS_P2_MFP[2]) determine the P2.2 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = PWM0_CH0 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = I2C1_SCL function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">ALT3   </td><td class="markdownTableBodyLeft">P2.3 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[3] (SYS_P2_MFP[11]), and MFP[3] (SYS_P2_MFP[3]) determine the P2.3 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = PWM0_CH1 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = I2C1_SDA1 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">ALT4   </td><td class="markdownTableBodyLeft">P2.4 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[4] (SYS_P2_MFP[12]), and MFP[4] (SYS_P2_MFP[4]) determine the P2.4 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = UART1_RXD function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = PWM0_CH2 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">ALT5   </td><td class="markdownTableBodyLeft">P2.5 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[5] (SYS_P2_MFP[13]), and MFP[5] (SYS_P2_MFP[5]) determine the P2.5 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = UART1_TXD function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = PWM0_CH3 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">ALT6   </td><td class="markdownTableBodyLeft">P2.6 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[6] (SYS_P2_MFP[14]), and MFP[6] (SYS_P2_MFP[6]) determine the P2.6 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = PWM0_CH4 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = ACMP1_O0 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">TYPE   </td><td class="markdownTableBodyLeft">P2[7:0] Input Schmitt Trigger Function Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = P2[7:0] I/O input Schmitt Trigger function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = P2[7:0] I/O input Schmitt Trigger function Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09806">9806</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga7400c0a92f4d16539f3d6acacd4795d1" name="ga7400c0a92f4d16539f3d6acacd4795d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7400c0a92f4d16539f3d6acacd4795d1">&#9670;&nbsp;</a></span>P3_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::P3_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md250"></a>
P3_MFP</h1>
<h2><a class="anchor" id="autotoc_md251"></a>
Offset: 0x3C  P3 Multiple Function and Input Type Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">MFP   </td><td class="markdownTableBodyLeft">P3 Multiple Function Select Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The pin function of P3 depends on MFP and ALT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to ALT Description for details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">ALT0   </td><td class="markdownTableBodyLeft">P3.0 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[0] (SYS_P3_MFP[8]), and MFP[0] (SYS_P3_MFP[0]) determine the P3.0 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = ACMP1_N function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = ADC_CH6 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">ALT1   </td><td class="markdownTableBodyLeft">P3.1 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The pin function of P3.1 depends on P3_MFP[1] and P3_ALT[1].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[1] (SYS_P3_MFP[9]), and MFP[1] (SYS_P3_MFP[1]) determine the P3.1 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = ACMP1_P0 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = ADC_CH7 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">ALT2   </td><td class="markdownTableBodyLeft">P3.2 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits P32EXT (SYS_P3_MFP[26]), ALT[2] (SYS_P3_MFP[10]), and MFP[2] (SYS_P3_MFP[2]) determine the P3.2 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 1) = INT1 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 0) = TM0_EXT function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 1) = STADC function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0, 0) = ACMP1_P1 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">ALT4   </td><td class="markdownTableBodyLeft">P3.4 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[4] (SYS_P3_MFP[12]), and MFP[4] (SYS_P3_MFP[4]) determine the P3.4 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = TM0_CNT_OUT function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = I2C0_SDA function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = ACMP1_P2 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">ALT5   </td><td class="markdownTableBodyLeft">P3.5 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[5] (SYS_P3_MFP[13]), and MFP[5] (SYS_P3_MFP[5]) determine the P3.5 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = TM1_CNT_OUTfunction is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = I2C0_SCL function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = ACMP1_P3 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">ALT6   </td><td class="markdownTableBodyLeft">P3.6 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[6] (SYS_P3_MFP[14]), and MFP[6] (SYS_P3_MFP[6]) determine the P3.6 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = TM1_EXT function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = CLKO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = ACMP0_O function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">TYPE   </td><td class="markdownTableBodyLeft">P3[7:0] Input Schmitt Trigger Function Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = P3[7:0] I/O input Schmitt Trigger function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = P3[7:0] I/O input Schmitt Trigger function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">P32EXT   </td><td class="markdownTableBodyLeft">P3.2 Alternate Function Selection Extension    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits P32EXT (SYS_P3_MFP[26]), ALT[2] (SYS_P3_MFP[10]), and MFP[2] (SYS_P3_MFP[2]) determine the P3.2 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0, 1) = INT1 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 0) = TM0_EXT function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1, 1) = STADC function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0, 0) = ACMP1_P1 function is selected.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09867">9867</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gad12e8207e4aa7a748e6c9d6d63281416" name="gad12e8207e4aa7a748e6c9d6d63281416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad12e8207e4aa7a748e6c9d6d63281416">&#9670;&nbsp;</a></span>P4_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::P4_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md252"></a>
P4_MFP</h1>
<h2><a class="anchor" id="autotoc_md253"></a>
Offset: 0x40  P4 Multiple Function and Input Type Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">MFP   </td><td class="markdownTableBodyLeft">P4 Multiple Function Select Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The pin function of P4 depends on MFP and ALT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to ALT Description for details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">ALT6   </td><td class="markdownTableBodyLeft">P4.6 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[6] (SYS_P4_MFP[6]), and MFP[6] (SYS_P4_MFP[6]) determine the P4.6 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = ICE_CLK function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = UART1_RXD function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">ALT7   </td><td class="markdownTableBodyLeft">P4.7 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[7] (SYS_P4_MFP[15]), and MFP[7] (SYS_P4_MFP[7]) determine the P4.7 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = ICE_DAT function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = UART1_TXD function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">TYPE   </td><td class="markdownTableBodyLeft">P4[7:0] Input Schmitt Trigger Function Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = P4[7:0] I/O input Schmitt Trigger function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = P4[7:0] I/O input Schmitt Trigger function Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09895">9895</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga26fcb8d118fa976019657257dbdb9876" name="ga26fcb8d118fa976019657257dbdb9876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26fcb8d118fa976019657257dbdb9876">&#9670;&nbsp;</a></span>P5_MFP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::P5_MFP</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md254"></a>
P5_MFP</h1>
<h2><a class="anchor" id="autotoc_md255"></a>
Offset: 0x44  P5 Multiple Function and Input Type Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">MFP   </td><td class="markdownTableBodyLeft">P5 Multiple Function Select Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The pin function of P5 depends on MFP and ALT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to ALT Description for details.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">ALT0   </td><td class="markdownTableBodyLeft">P5.0 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The pin function of P5.0 depends on MFP[0] and ALT[0].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[0] (SYS_P5_MFP[8]), and MFP[0] (SYS_P5_MFP[0]) determine the P5.0 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = XT1_IN function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = I2C1_SDA1 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = UART0_TXD function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: To enable external XTAL function, the CLK_PWRCTL bit [1:0] (XTLEN), external HXT or LXT crystal oscillator control register must also be set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">ALT1   </td><td class="markdownTableBodyLeft">P5.1 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[1] (SYS_P5_MFP[9]), and MFP[1] (SYS_P5_MFP[1]) determine the P5.1 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = XT1_OUT function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 0) = I2C1_SCL1 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(1, 1) = UART0_RXD function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: To enable external XTAL function, the CLK_PWRCTL bit [1:0] (XTLEN), external HXT or LXT crystal oscillator control register must also be set.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">ALT2   </td><td class="markdownTableBodyLeft">P5.2 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[2] (SYS_P5_MFP[10]), and MFP[2] (SYS_P5_MFP[2]) determine the P5.2 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = INT1 function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">ALT3   </td><td class="markdownTableBodyLeft">P5.3 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[3] (SYS_P5_MFP[11]), and MFP[3] (SYS_P5_MFP[3]) determine the P5.3 function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 1) = ADC_CH0 function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[12]   </td><td class="markdownTableBodyCenter">ALT4   </td><td class="markdownTableBodyLeft">P5.4 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[4] (SYS_P5_MFP[12]), and MFP[4] (SYS_P5_MFP[4]) determine the P5.4 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13]   </td><td class="markdownTableBodyCenter">ALT5   </td><td class="markdownTableBodyLeft">P5.5 Alternate Function Select Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Bits ALT[5] (SYS_P5_MFP[13]), and MFP[5] (SYS_P5_MFP[5]) determine the P5.5 function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(0, 0) = GPIO function is selected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Others = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[23:16]   </td><td class="markdownTableBodyCenter">TYPE   </td><td class="markdownTableBodyLeft">P5[7:0] Input Schmitt Trigger Function Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = P5[7:0] I/O input Schmitt Trigger function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = P5[7:0] I/O input Schmitt Trigger function Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09944">9944</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gac1f574b481deedb607735d2c773b3179" name="gac1f574b481deedb607735d2c773b3179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1f574b481deedb607735d2c773b3179">&#9670;&nbsp;</a></span>PCACTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PCACTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md214"></a>
PCACTL</h1>
<h2><a class="anchor" id="autotoc_md215"></a>
Offset: 0x88  PWM Precise Center-Aligned Type Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">PCAEN   </td><td class="markdownTableBodyLeft">PWM Precise Center-aligned Type Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Precise center-aligned type Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Precise center-aligned type Enabled.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07835">7835</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga6246fa552c418eb242d8bb15ebb045ba" name="ga6246fa552c418eb242d8bb15ebb045ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6246fa552c418eb242d8bb15ebb045ba">&#9670;&nbsp;</a></span>PDID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SYS_T::PDID</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md234"></a>
PDID</h1>
<h2><a class="anchor" id="autotoc_md235"></a>
Offset: 0x00  Part Device Identification Number Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">PDID   </td><td class="markdownTableBodyLeft">Product Device Identification Number (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This register reflects the device part number code.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Software can read this register to identify which device is use.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, the MINI58LDE PDID code is "0x00A05800".   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09480">9480</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gadbcfb607febd5575d9614063438f7e9a" name="gadbcfb607febd5575d9614063438f7e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbcfb607febd5575d9614063438f7e9a">&#9670;&nbsp;</a></span>PERIOD0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PERIOD0</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md164"></a>
PERIOD0</h1>
<h2><a class="anchor" id="autotoc_md165"></a>
Offset: 0x0C  PWM Counter Period Register 0</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD0   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD1   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD2   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD3   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD4   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD5   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05673">5673</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gaaae0d4237b99bac4e9d739c0da116c92" name="gaaae0d4237b99bac4e9d739c0da116c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaae0d4237b99bac4e9d739c0da116c92">&#9670;&nbsp;</a></span>PERIOD1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PERIOD1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md166"></a>
PERIOD1</h1>
<h2><a class="anchor" id="autotoc_md167"></a>
Offset: 0x10  PWM Counter Period Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD0   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD1   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD2   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD3   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD4   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD5   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05779">5779</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga5e0603b2229e6c7d599c3a38363919fc" name="ga5e0603b2229e6c7d599c3a38363919fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e0603b2229e6c7d599c3a38363919fc">&#9670;&nbsp;</a></span>PERIOD2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PERIOD2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md168"></a>
PERIOD2</h1>
<h2><a class="anchor" id="autotoc_md169"></a>
Offset: 0x14  PWM Counter Period Register 2</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD0   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD1   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD2   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD3   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD4   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD5   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05885">5885</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga5096612d276212791e563f235187dab6" name="ga5096612d276212791e563f235187dab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5096612d276212791e563f235187dab6">&#9670;&nbsp;</a></span>PERIOD3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PERIOD3</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md170"></a>
PERIOD3</h1>
<h2><a class="anchor" id="autotoc_md171"></a>
Offset: 0x18  PWM Counter Period Register 3</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD0   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD1   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD2   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD3   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD4   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD5   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l05991">5991</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga04f2a4f4e055fbec4012873272d6d90e" name="ga04f2a4f4e055fbec4012873272d6d90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04f2a4f4e055fbec4012873272d6d90e">&#9670;&nbsp;</a></span>PERIOD4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PERIOD4</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md172"></a>
PERIOD4</h1>
<h2><a class="anchor" id="autotoc_md173"></a>
Offset: 0x1C  PWM Counter Period Register 4</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD0   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD1   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD2   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD3   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD4   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD5   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l06097">6097</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga5d4238430a1480277cb7aef7120571a9" name="ga5d4238430a1480277cb7aef7120571a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d4238430a1480277cb7aef7120571a9">&#9670;&nbsp;</a></span>PERIOD5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PERIOD5</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md174"></a>
PERIOD5</h1>
<h2><a class="anchor" id="autotoc_md175"></a>
Offset: 0x20  PWM Counter Period Register 5</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD0   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD1   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD2   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD3   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD4   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:0]   </td><td class="markdownTableBodyCenter">PERIOD5   </td><td class="markdownTableBodyLeft">PWM Counter Period Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PERIODn determines the PWM counter period.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Edge-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (CMPn+1)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Center-aligned type:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Duty ratio = (PERIODn - CMPn)/( PERIODn+1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &gt;= PERIODn: PWM output is always low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn &lt; PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(Unit = One PWM clock cycle).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Any write to PERIODn will take effect in the next PWM cycle.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l06203">6203</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gac16ad4728fef0e6e932b4a344ecbf33f" name="gac16ad4728fef0e6e932b4a344ecbf33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac16ad4728fef0e6e932b4a344ecbf33f">&#9670;&nbsp;</a></span>PHCHG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PHCHG</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md206"></a>
PHCHG</h1>
<h2><a class="anchor" id="autotoc_md207"></a>
Offset: 0x78  PWM Phase Changed Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT0   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT1   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT2   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT3   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT4   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT5   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">MSKDAT6   </td><td class="markdownTableBodyLeft">PWM0_CH6 (GPIO P0.1) Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MASKEND6 Is 1, channel 6's output level is MSKDAT6.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH6 output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH6 output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">MSKDAT7   </td><td class="markdownTableBodyLeft">PWM0_CH7 (GPIO P0.0) Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MASKEND7 Is 1, channel 7's output level is MSKDAT7.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH7 output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH7 output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN0   </td><td class="markdownTableBodyLeft">PWMn Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN1   </td><td class="markdownTableBodyLeft">PWMn Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN2   </td><td class="markdownTableBodyLeft">PWMn Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN3   </td><td class="markdownTableBodyLeft">PWMn Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN4   </td><td class="markdownTableBodyLeft">PWMn Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN5   </td><td class="markdownTableBodyLeft">PWMn Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">AUTOCLR0   </td><td class="markdownTableBodyLeft">Hardware Auto Clear ACMP0TEN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Hardware will auto clear ACMP0TEN when ACMP0 trigger PWM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Hardware will not auto clear ACMP0TEN when ACMP0 trigger PWM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">AUTOCLR1   </td><td class="markdownTableBodyLeft">Hardware Auto Clear ACMP1TEN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Hardware will auto clear ACMP1TEN when ACMP1 trigger PWM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Hardware will not auto clear ACMP1TEN when ACMP1 trigger PWM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">AOFFEN01   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Channel 0 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 0 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH0 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH0 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">AOFFEN11   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Channel 1 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 1 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH1 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH1 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">AOFFEN21   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Channel 2 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 2 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH2 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH2 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH 3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">AOFFEN31   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Channel 3 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 3 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH3 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH3 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:20]   </td><td class="markdownTableBodyCenter">A1POSSEL   </td><td class="markdownTableBodyLeft">ACMP1 Positive Input Source Select Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Select P3.1 as the input of ACMP1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Select P3.2 as the input of ACMP1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Select P3.3 as the input of ACMP1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Select P3.4 as the input of ACMP1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">TMR1TEN   </td><td class="markdownTableBodyLeft">TIMER1 Trigger PWM Function Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set, TIMER1 time-out event will update PWM_PHCHG with PHCHG_NXT register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TIMER1 trigger PWM function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TIMER1 trigger PWM function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">ACMP1TEN   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Function Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ACMP1 trigger PWM function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ACMP1 trigger PWM function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared when ACMP1 trigger PWM if AUTOCLR1 is set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">AOFFEN00   </td><td class="markdownTableBodyLeft">ACMP0 Trigger Channel 0 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 0 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH0 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH0 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">AOFFEN10   </td><td class="markdownTableBodyLeft">ACMP0 Trigger Channel 1 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 1 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH1 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH1 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">AOFFEN20   </td><td class="markdownTableBodyLeft">ACMP0 Trigger Channel 2 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 2 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH2 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH2 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">AOFFEN30   </td><td class="markdownTableBodyLeft">ACMP0 Trigger Channel 3 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 3 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH3 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH3 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~ PWM0_CH3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:28]   </td><td class="markdownTableBodyCenter">A0POSSEL   </td><td class="markdownTableBodyLeft">ACMP0 Positive Input Source Select Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Select P1.5 as the input of ACMP0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Select P1.0 as the input of ACMP0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Select P1.2 as the input of ACMP0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Select P1.3 as the input of ACMP0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">TMR0TEN   </td><td class="markdownTableBodyLeft">TIMER0 Trigger PWM Function Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set, TIMER0 time-out event will update PWM_PHCHG with PHCHG_NXT register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TIMER0 trigger PWM function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TIMER0 trigger PWM function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">ACMP0TEN   </td><td class="markdownTableBodyLeft">ACMP0 Trigger PWM Function Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ACMP0 trigger PWM function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ACMP0 trigger PWM function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared when ACMP0 trigger PWM if AUTOCLR0 is set.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07651">7651</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga38b5faca3f91ca97e0efe65b3a6115af" name="ga38b5faca3f91ca97e0efe65b3a6115af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38b5faca3f91ca97e0efe65b3a6115af">&#9670;&nbsp;</a></span>PHCHGMSK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PHCHGMSK</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md210"></a>
PHCHGMSK</h1>
<h2><a class="anchor" id="autotoc_md211"></a>
Offset: 0x80  PWM Phase Change Mask Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">MASKEND6   </td><td class="markdownTableBodyLeft">PWM0_CH6 (GPIO P0.1) Output Mask Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output the original GPIO P0.1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output MSKDAT6 specified in bit 6 of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">MASKEND7   </td><td class="markdownTableBodyLeft">PWM0_CH7 (GPIO P0.0) Output Mask Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output the original GPIO P0.0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output MSKDAT7 specified in bit 7 of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">POSCTL0   </td><td class="markdownTableBodyLeft">Positive Input Control For ACMP0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The input of ACMP is controlled by CMP0CR.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The input of ACMP is controlled by CMP0SEL of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Register CMP0CR is described in Comparator Controller chapter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">POSCTL1   </td><td class="markdownTableBodyLeft">Positive Input Control For ACMP1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The input of ACMP is controlled by CMP1CR.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The input of ACMP is controlled by CMP1SEL of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Register CMP1CR is described in Comparator Controller chapter.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07807">7807</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gac8d356a2be6cfaeb9c2f62626e8e8601" name="gac8d356a2be6cfaeb9c2f62626e8e8601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8d356a2be6cfaeb9c2f62626e8e8601">&#9670;&nbsp;</a></span>PHCHGNXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::PHCHGNXT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md208"></a>
PHCHGNXT</h1>
<h2><a class="anchor" id="autotoc_md209"></a>
Offset: 0x7C  PWM Next Phase Change Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT0   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT1   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT2   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT3   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT4   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">MSKDAT5   </td><td class="markdownTableBodyLeft">PWM0_CHn Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MSKENn is 0, channel n's output level is MSKDATn.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CHn output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CHn output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">MSKDAT6   </td><td class="markdownTableBodyLeft">PWM0_CH6 (GPIO P0.1) Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MASKEND6 Is 1, channel 6's output level is MSKDAT6.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH6 output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH6 output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">MSKDAT7   </td><td class="markdownTableBodyLeft">PWM0_CH7 (GPIO P0.0) Mask Data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When MASKEND7 Is 1, channel 7's output level is MSKDAT7.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH7 output low level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH7 output high level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN0   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN1   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN2   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN3   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN4   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[13:8]   </td><td class="markdownTableBodyCenter">MSKEN5   </td><td class="markdownTableBodyLeft">PWM Output Mask Enable Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Output MSKDATn specified in bit n of PWM_PHCHG register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Output the original channel n waveform.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[14]   </td><td class="markdownTableBodyCenter">AUTOCLR0   </td><td class="markdownTableBodyLeft">Hardware Auto Clear ACMP0TEN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Hardware will auto clear ACMP0TEN when ACMP0 trigger PWM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Hardware will not auto clear ACMP0TEN when ACMP0 trigger PWM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[15]   </td><td class="markdownTableBodyCenter">AUTOCLR1   </td><td class="markdownTableBodyLeft">Hardware Auto Clear ACMP1TEN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Hardware will auto clear ACMP1TEN when ACMP1 trigger PWM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Hardware will not auto clear ACMP1TEN when ACMP1 trigger PWM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">AOFFEN01   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Channel 0 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 0 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH0 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH0 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">AOFFEN11   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Channel 1 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 1 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH1 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH1 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">AOFFEN21   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Channel 2 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 2 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH2 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH2 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">AOFFEN31   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Channel 3 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 3 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH3 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH3 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[21:20]   </td><td class="markdownTableBodyCenter">A1POSSEL   </td><td class="markdownTableBodyLeft">ACMP1 Positive Input Source Select Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Select P3.1 as the input of ACMP1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Select P3.2 as the input of ACMP1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Select P3.3 as the input of ACMP1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Select P3.4 as the input of ACMP1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[22]   </td><td class="markdownTableBodyCenter">TMR1TEN   </td><td class="markdownTableBodyLeft">TMR1 Trigger PWM Function Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set, TMR1 time-out event will update PWM_PHCHG with PHCHG_NXT register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMR1 trigger PWM function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMR1 trigger PWM function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[23]   </td><td class="markdownTableBodyCenter">ACMP1TEN   </td><td class="markdownTableBodyLeft">ACMP1 Trigger Function Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ACMP1 trigger PWM function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ACMP1 trigger PWM function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared when ACMP1 trigger PWM if AUTOCLR1 is set.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">AOFFEN00   </td><td class="markdownTableBodyLeft">ACMP0 Trigger Channel 0 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 0 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH0 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH0 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">AOFFEN10   </td><td class="markdownTableBodyLeft">ACMP0 Trigger Channel 1 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 1 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH1 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH1 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">AOFFEN20   </td><td class="markdownTableBodyLeft">ACMP0 Trigger Channel 2 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 2 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH2 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH2 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">AOFFEN30   </td><td class="markdownTableBodyLeft">ACMP0 Trigger Channel 3 One Cycle Output Off Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting this bit will force PWM channel 3 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM0_CH3 one period cycle output low Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM0_CH3 one period cycle output low Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This function is only available for PWM0_CH0~PWM0_CH3.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[29:28]   </td><td class="markdownTableBodyCenter">A0POSSEL   </td><td class="markdownTableBodyLeft">ACMP0 Positive Input Source Select Bits    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Select P1.5 as the input of ACMP0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Select P1.0 as the input of ACMP0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Select P1.2 as the input of ACMP0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Select P1.3 as the input of ACMP0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[30]   </td><td class="markdownTableBodyCenter">TMR0TEN   </td><td class="markdownTableBodyLeft">TMR0 Trigger PWM Function Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When this bit is set, TMR0 time-out event will update PWM_PHCHG with PHCHG_NXT register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = TMR0 trigger PWM function Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = TMR0 trigger PWM function Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">ACMP0TEN   </td><td class="markdownTableBodyLeft">ACMP0 Trigger Function Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ACMP0 trigger PWM function Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ACMP0 trigger PWM function Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be auto cleared when ACMP0 trigger PWM if AUTOCLR0 is set.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07783">7783</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gacd64ba4db747a13e65ee2ff1eaa0fe47" name="gacd64ba4db747a13e65ee2ff1eaa0fe47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd64ba4db747a13e65ee2ff1eaa0fe47">&#9670;&nbsp;</a></span>PIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t GPIO_T::PIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md72"></a>
PIN</h1>
<h2><a class="anchor" id="autotoc_md73"></a>
Offset: 0x10  P0 Pin Value</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">PIN0   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Pin Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each bit of the register reflects the actual status of the respective Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">PIN1   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Pin Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each bit of the register reflects the actual status of the respective Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">PIN2   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Pin Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each bit of the register reflects the actual status of the respective Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">PIN3   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Pin Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each bit of the register reflects the actual status of the respective Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">PIN4   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Pin Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each bit of the register reflects the actual status of the respective Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">PIN5   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Pin Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each bit of the register reflects the actual status of the respective Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">PIN6   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Pin Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each bit of the register reflects the actual status of the respective Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">PIN7   </td><td class="markdownTableBodyLeft">Port 0-5 Pin[N] Pin Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Each bit of the register reflects the actual status of the respective Px.n pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 0, n=2, n=3 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 1, n=1, n=6, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 2, n=0, n=1, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 3, n=3, n=7 are reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 4, n=0,.5 are reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Max. n=7 for port 5, n=6, n=7 are reserved.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l02167">2167</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga0059b5b729980b9dfe3a9cb3e75ea99a" name="ga0059b5b729980b9dfe3a9cb3e75ea99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0059b5b729980b9dfe3a9cb3e75ea99a">&#9670;&nbsp;</a></span>PLLCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::PLLCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md44"></a>
PLLCTL</h1>
<h2><a class="anchor" id="autotoc_md45"></a>
Offset: 0x20  PLL Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8:0]   </td><td class="markdownTableBodyCenter">FBDIV   </td><td class="markdownTableBodyLeft">PLL Feedback Divider Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to the formulas below the table.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[13:9]   </td><td class="markdownTableBodyCenter">INDIV   </td><td class="markdownTableBodyLeft">PLL Input Divider Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to the formulas below the table.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:14]   </td><td class="markdownTableBodyCenter">OUTDIV   </td><td class="markdownTableBodyLeft">PLL Output Divider Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to the formulas below the table.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">PD   </td><td class="markdownTableBodyLeft">Power-down Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the PDEN bit is set to 1 in CLK_PWRCTL register, the PLL will enter Power-down mode too.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PLL is in Normal mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PLL is in Power-down mode (default).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">BP   </td><td class="markdownTableBodyLeft">PLL Bypass Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PLL is in Normal mode (default).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PLL clock output is same as PLL source clock input.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[18]   </td><td class="markdownTableBodyCenter">OE   </td><td class="markdownTableBodyLeft">PLL OE (FOUT Enable) Pin Control    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PLL FOUT Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PLL FOUT is fixed low.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[19]   </td><td class="markdownTableBodyCenter">PLLSRC   </td><td class="markdownTableBodyLeft">PLL Source Clock Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PLL source clock from HXT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PLL source clock from HIRC.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l01144">1144</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2f67a013b10cb1eaa23348156c5b3171" name="ga2f67a013b10cb1eaa23348156c5b3171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f67a013b10cb1eaa23348156c5b3171">&#9670;&nbsp;</a></span>POEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t PWM_T::POEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md192"></a>
POEN</h1>
<h2><a class="anchor" id="autotoc_md193"></a>
Offset: 0x5C  PWM Output Enable Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">POEN0   </td><td class="markdownTableBodyLeft">PWM Output Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output to pin Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output to pin Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The corresponding GPIO pin must be switched to PWM function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">POEN1   </td><td class="markdownTableBodyLeft">PWM Output Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output to pin Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output to pin Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The corresponding GPIO pin must be switched to PWM function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">POEN2   </td><td class="markdownTableBodyLeft">PWM Output Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output to pin Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output to pin Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The corresponding GPIO pin must be switched to PWM function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">POEN3   </td><td class="markdownTableBodyLeft">PWM Output Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output to pin Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output to pin Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The corresponding GPIO pin must be switched to PWM function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">POEN4   </td><td class="markdownTableBodyLeft">PWM Output Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output to pin Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output to pin Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The corresponding GPIO pin must be switched to PWM function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5:0]   </td><td class="markdownTableBodyCenter">POEN5   </td><td class="markdownTableBodyLeft">PWM Output Enable Bits    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = PWM channel n output to pin Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = PWM channel n output to pin Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The corresponding GPIO pin must be switched to PWM function.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l07200">7200</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8dc40f2a57b0b379fd97dd6eecdba230" name="ga8dc40f2a57b0b379fd97dd6eecdba230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dc40f2a57b0b379fd97dd6eecdba230">&#9670;&nbsp;</a></span>PWRCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::PWRCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md28"></a>
PWRCTL</h1>
<h2><a class="anchor" id="autotoc_md29"></a>
Offset: 0x00  System Power-down Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1:0]   </td><td class="markdownTableBodyCenter">XTLEN   </td><td class="markdownTableBodyLeft">External HXT Or LXT Crystal Oscillator Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The default clock source is from HIRC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">These two bits are default set to "00" and the XT1_IN and XT1_OUT pins are GPI.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = XT1_IN and XT1_OUT are GPIO, disable both LXT &amp; HXT (default).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = HXT Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = LXT Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = XT1_IN is external clock input pin, XT1_OUT is GPIO.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: To enable external XTAL function, ALT[1:0] and MFP[1:0] bits must also be set in SYS_P5_MFP.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">HIRCEN   </td><td class="markdownTableBodyLeft">HIRC Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = 22.1184 MHz internal high speed RC oscillator (HIRC) Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 22.1184 MHz internal high speed RC oscillator (HIRC) Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The default of HIRCEN bit is 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">LIRCEN   </td><td class="markdownTableBodyLeft">LIRC Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = 10 kHz internal low speed RC oscillator (LIRC) Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = 10 kHz internal low speed RC oscillator (LIRC) Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">PDWKDLY   </td><td class="markdownTableBodyLeft">Wake-up Delay Counter Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The delayed clock cycle is 4096 clock cycles when chip work at 4~24 MHz external high speed crystal (HXT), 4096 clock cycles for 32.768 kHz external low speed crystal (LXT), and 16 clock cycles when chip works at 22.1184 MHz internal high speed RC oscillator (HIRC).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Clock cycles delay Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clock cycles delay Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">PDWKIEN   </td><td class="markdownTableBodyLeft">Power-down Mode Wake-up Interrupt Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Power-down mode wake-up interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Power-down mode wake-up interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The interrupt will occur when both PDWKIF and PDWKIEN are high.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[6]   </td><td class="markdownTableBodyCenter">PDWKIF   </td><td class="markdownTableBodyLeft">Power-down Mode Wake-up Interrupt Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set by "Power-down wake-up event", which indicates that resume from Power-down mode    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The flag is set if the GPIO, UART, WDT, ACMP, Timer or BOD wake-up occurred.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit works only if PDWKIEN (CLK_PWRCTL[5]) set to 1. Write 1 to clear the bit to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">PDEN   </td><td class="markdownTableBodyLeft">System Power-down Enable Bit (Write Protect)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When chip wakes up from Power-down mode, this bit is cleared by hardware.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">User needs to set this bit again for next Power-down.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Power-down mode, 4~24 MHz external high speed crystal oscillator (HXT), 32.768 kHz external low speed crystal oscillator (LXT), and the 22.1184 MHz internal high speed oscillator (HIRC) will be disabled in this mode, and 10 kHz internal low speed RC oscillator (LIRC) are not controlled by Power-down mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In Power-down mode, the PLL and system clock are disabled, and ignored the clock source selection.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from 10 kHz internal low speed oscillator.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Chip operating normally or chip in Idle mode because of WFI command.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">PDLXT   </td><td class="markdownTableBodyLeft">Enable LXT In Power-down Mode    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit controls the crystal oscillator active or not in Power-down mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect to Power-down mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = If XTLEN[1:0] = 10, LXT is still active in Power-down mode.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00876">876</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga7e2bb002e04a7eec46d6d2d324d3ce9b" name="ga7e2bb002e04a7eec46d6d2d324d3ce9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e2bb002e04a7eec46d6d2d324d3ce9b">&#9670;&nbsp;</a></span>REGLCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SYS_T::REGLCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md262"></a>
REGLCTL</h1>
<h2><a class="anchor" id="autotoc_md263"></a>
Offset: 0x100  Register Write-Protection Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">REGLCTL   </td><td class="markdownTableBodyLeft">Register Write-protection Code (Write Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Some registers have write-protection function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Writing these registers have to disable the protected function by writing the sequence value 0x59, 0x16, 0x88 to this field.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal writ.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Register Write-protection Disable Index (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Write-protection Enabled for writing protected registers.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Any write to the protected register is ignore.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Write-protection Disabled for writing protected registers.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Protected registers are listed below:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SYS_IPRST0 (0x5000_0008) : Peripheral Reset Control Resister 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">SYS_BODCTL (0x5000_0018) : Brown-out Detector Control Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CLK_PWRCTL (0x5000_0200) : Bit[6] is not protected for power wake-up interrupt clear.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CLK_APBCLK bit[0] (0x5000_0208) : Bit[0] is watchdog clock enable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CLK_CLKSEL0 (0x5000_0210) : HCLK and CPU STCLK clock source select.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">CLK_CLKSEL1 bit[1:0] (0x5000_0214) : Watchdog clock source select.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">NMI_SEL bit[8] (0x5000_0380) : NMI interrupt enable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ISPCON (0x5000_C000) : Flash ISP Control.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">ISPTRG (0x5000_C010) : ISP Trigger Control.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">WTCR (0x4000_4000) : Watchdog Timer Control.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: The bits which are write-protected will be noted as" (Write Protect)" beside the description.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l10055">10055</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga501fa437f75d2cfbcedb28e1703eacd4" name="ga501fa437f75d2cfbcedb28e1703eacd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga501fa437f75d2cfbcedb28e1703eacd4">&#9670;&nbsp;</a></span>RLDCNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t WWDT_T::RLDCNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md308"></a>
RLDCNT</h1>
<h2><a class="anchor" id="autotoc_md309"></a>
Offset: 0x00  WWDT Reload Counter Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">RLDCNT   </td><td class="markdownTableBodyLeft">WWDT Reload Counter Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT (WWDT_CTL[21:16]).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If user writes WWDT_RLDCNT when current WWDT counter value is larger than CMPDAT, WWDT reset signal will generate immediately.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11541">11541</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gadf3b921bb87def94dcc5dd252c6fd85d" name="gadf3b921bb87def94dcc5dd252c6fd85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf3b921bb87def94dcc5dd252c6fd85d">&#9670;&nbsp;</a></span>RSTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SYS_T::RSTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md236"></a>
RSTSTS</h1>
<h2><a class="anchor" id="autotoc_md237"></a>
Offset: 0x04  System Reset Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">PORF   </td><td class="markdownTableBodyLeft">POR Reset Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The POR reset flag is set by the "Reset Signal" from the Power-on Reset (POR) Controller or bit CHIPRST (SYS_IPRST0[0]) to indicate the previous reset source.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from POR or CHIPRST.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Power-on-Reset (POR) or CHIPRST had issued the reset signal to reset the system.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software can write 1 to clear this bit to zero.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">PINRF   </td><td class="markdownTableBodyLeft">NRESET Pin Reset Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The nRESET pin reset flag is set by the "Reset Signal" from the nRESET pin to indicate the previous reset source.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from nRESET pin.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Pin nRESET had issued the reset signal to reset the system.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software can write 1 to clear this bit to zero.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">WDTRF   </td><td class="markdownTableBodyLeft">WDT Reset Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The WDT reset flag is set by the "Reset Signal" from the Watchdog Timer or Window Watchdog Timer to indicate the previous reset source.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from watchdog timer or window watchdog timer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The watchdog timer or window watchdog timer had issued the reset signal to reset the system.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software can write 1 to clear this bit to zero.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">BODRF   </td><td class="markdownTableBodyLeft">BOD Reset Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The BOD reset flag is set by the "Reset Signal" from the Brown-out Detector to indicate the previous reset source.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from BOD.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The BOD had issued the reset signal to reset the system.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software can write 1 to clear this bit to zero.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">SYSRF   </td><td class="markdownTableBodyLeft">System Reset Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The system reset flag is set by the "Reset Signal" from the Cortex-M0 Core to indicate the previous reset source.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from Cortex-M0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ (SCS_AIRCR[2]), Application Interrupt and Reset Control Register, address = 0xE000ED0C in system control registers of Cortex-M0 core.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software can write 1 to clear this bit to zero.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CPURF   </td><td class="markdownTableBodyLeft">CPU Reset Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The CPU reset flag is set by hardware if software writes CPURST (SYS_IPRST0[1]) 1 to reset Cortex-M0 Core and Flash Memory Controller (FMC).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from CPU.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The Cortex-M0 Core and FMC are reset by software setting CPURST to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software can write 1 to clear this bit to zero.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">CPULKRF   </td><td class="markdownTableBodyLeft">The Cortex-M0 LOCKUP Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No reset from Cortex-M0 LOCKUP happened.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The Cortex-M0 LOCKUP happened and chip is reset.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Software can write 1 to clear this bit to zero.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09524">9524</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga037f046c43f269db9625dd1fc13b5392" name="ga037f046c43f269db9625dd1fc13b5392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga037f046c43f269db9625dd1fc13b5392">&#9670;&nbsp;</a></span>RX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t SPI_T::RX</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md224"></a>
RX</h1>
<h2><a class="anchor" id="autotoc_md225"></a>
Offset: 0x10  SPI Data Receive Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">RX   </td><td class="markdownTableBodyLeft">Data Receive Register (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Receive Register holds the value of received data of the last executed transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Valid bits depend on the transmit bit length field DWIDTH in the SPI_CTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if DWIDTH is set to 0x08, the bit field RX[7:0] holds the received data.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The values of the other bits are unknown.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Receive Register is read-only register.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09134">9134</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga5e86b3f633ef48ebbce59a38ada22b0d" name="ga5e86b3f633ef48ebbce59a38ada22b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e86b3f633ef48ebbce59a38ada22b0d">&#9670;&nbsp;</a></span>SEQCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::SEQCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md22"></a>
SEQCTL</h1>
<h2><a class="anchor" id="autotoc_md23"></a>
Offset: 0x4C  A/D PWM Sequential Mode Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">SEQEN   </td><td class="markdownTableBodyLeft">ADC Sequential Mode Enable Bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When ADC sequential mode is enabled, two of three ADC channels from 0 to 2 will automatically convert analog data in the sequence of channel [0, 1] or channel[1, 2] or channel[0, 2] defined by MODESEL (ADC_SEQCTL[3:2]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ADC sequential mode Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ADC sequential mode Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">SEQTYPE   </td><td class="markdownTableBodyLeft">ADC Sequential Mode Type    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = ADC delay time is only inserted before the first conversion.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The second conversion starts immediately after the first conversion is completed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">(for 2/3-shunt type).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = ADC delay time is inserted before each conversion. (for 1-shunt type)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3:2]   </td><td class="markdownTableBodyCenter">MODESEL   </td><td class="markdownTableBodyLeft">ADC Sequential Mode Selection    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Issue ADC_INT after Channel 0 then Channel 1 conversion finishes when SEQEN =1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Issue ADC_INT after Channel 1 then Channel 2 conversion finishes when SEQEN =1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Issue ADC_INT after Channel 0 then Channel 2 conversion finishes when SEQEN =1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11:8]   </td><td class="markdownTableBodyCenter">TRG1CTL   </td><td class="markdownTableBodyLeft">PWM Trigger Source Selection For TRG1CTL[3:2]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = PWM Trigger source is PWM0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = PWM Trigger source is PWM2.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = PWM Trigger source is PWM4.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = PWM Trigger source is reserved.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM Trigger Type Selection for TRG1CTL[1:0]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Rising of the selected PWM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Center of the selected PWM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Falling of the selected PWM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Period of the selected PWM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: PWM trigger source is valid for 1-shunt and 2/3-shunt type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[19:16]   </td><td class="markdownTableBodyCenter">TRG2CTL   </td><td class="markdownTableBodyLeft">PWM Trigger Source Selection For TRG2CTL[3:2]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = PWM Trigger source is PWM0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = PWM Trigger source is PWM2.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = PWM Trigger source is PWM4.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = PWM Trigger source is reserved.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM Trigger Type Selection for TRG2CTL[1:0]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">00 = Rising of the selected PWM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">01 = Center of the selected PWM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">10 = Falling of the selected PWM.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">11 = Period of the selected PWM.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: PWM trigger source is valid for 1-shunt type.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00613">613</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga45b116c9fe25fae953000a3db56eddbc" name="ga45b116c9fe25fae953000a3db56eddbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45b116c9fe25fae953000a3db56eddbc">&#9670;&nbsp;</a></span>SEQDAT1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t ADC_T::SEQDAT1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md24"></a>
SEQDAT1</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
Offset: 0x50  A/D PWM Sequential Mode First Result Register1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9:0]   </td><td class="markdownTableBodyCenter">RESULT   </td><td class="markdownTableBodyLeft">A/D PWM Sequential Mode Conversion Result    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field contains conversion result of ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">OV   </td><td class="markdownTableBodyLeft">Over Run Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If converted data in RESULT[9:0] has not been read before the new conversion result is loaded to this register, OV is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is cleared by hardware after the ADC_DAT register is read.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Data in RESULT[9:0] is recent conversion result.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Data in RESULT[9:0] overwritten.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">VALID   </td><td class="markdownTableBodyLeft">Valid Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to 1 when ADC conversion is completed and cleared by hardware after the ADC_DAT register is read.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Data in RESULT[9:0] bits not valid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Data in RESULT[9:0] bits valid.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00634">634</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8757666587594e61e290ba49da4558a1" name="ga8757666587594e61e290ba49da4558a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8757666587594e61e290ba49da4558a1">&#9670;&nbsp;</a></span>SEQDAT2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t ADC_T::SEQDAT2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md26"></a>
SEQDAT2</h1>
<h2><a class="anchor" id="autotoc_md27"></a>
Offset: 0x54  A/D PWM Sequential Mode Second Result Register1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9:0]   </td><td class="markdownTableBodyCenter">RESULT   </td><td class="markdownTableBodyLeft">A/D PWM Sequential Mode Conversion Result    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field contains conversion result of ADC.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">OV   </td><td class="markdownTableBodyLeft">Over Run Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If converted data in RESULT[9:0] has not been read before the new conversion result is loaded to this register, OV is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is cleared by hardware after the ADC_DAT register is read.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Data in RESULT[9:0] is recent conversion result.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Data in RESULT[9:0] overwritten.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[17]   </td><td class="markdownTableBodyCenter">VALID   </td><td class="markdownTableBodyLeft">Valid Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set to 1 when ADC conversion is completed and cleared by hardware after the ADC_DAT register is read.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Data in RESULT[9:0] bits not valid.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Data in RESULT[9:0] bits valid.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00655">655</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gab6477ea2c2d420604feccb3c1b62e593" name="gab6477ea2c2d420604feccb3c1b62e593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6477ea2c2d420604feccb3c1b62e593">&#9670;&nbsp;</a></span>SLVCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::SLVCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md228"></a>
SLVCTL</h1>
<h2><a class="anchor" id="autotoc_md229"></a>
Offset: 0x3C  SPI Slave Control and Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">SLV3WIRE   </td><td class="markdownTableBodyLeft">Slave 3-wire Mode Enable Bit (Slave Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The SPI controller work with 3-wire interface including SPI_CLK, SPI_MISO, and SPI_MOSI.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The controller is 4-wire bi-direction interface in Slave mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The controller is 3-wire bi-direction interface in Slave mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The controller will be ready to transmit/receive data after the SPIEN bit is set to .    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: In Slave 3-wire mode, the SSLTEN bit (SPI_SSCTL[4]) shall be set as 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[9]   </td><td class="markdownTableBodyCenter">SLVABT   </td><td class="markdownTableBodyLeft">Slave 3-wire Mode Abort Control Bit (Slave Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In normal operation, there is an interrupt event when the number of received bits meets the requirement which defined in DWIDTH.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If the number of received bits is less than the requirement and there is no more bus clock input over one transfer time in Slave 3-wire mode, user can set this bit to force the current transfer done and then user can get a unit transfer interrupt event.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No force the transfer done when the SLV3WIRE bit is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Force the transfer done when the SLV3WIRE bit is set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[10]   </td><td class="markdownTableBodyCenter">SLVSTIEN   </td><td class="markdownTableBodyLeft">Slave 3-wire Mode Start Interrupt Enable (Slave Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to enable interrupt when the transfer has started in Slave 3-wire mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If there is no transfer done interrupt over the time period which is defined by user after the transfer start, user can set the SLVABT bit to force the transfer don.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Transaction start interrupt Disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Transaction start interrupt Enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It will be cleared to 0 as the current transfer is done or the SLVSTIF bit is cleared to 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">SLVSTIF   </td><td class="markdownTableBodyLeft">Slave 3-wire Mode Start Interrupt Status (Slave Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit dedicates if a transaction has started in Slave 3-wire mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Slave does not detect any SPI bus clock transfer since the SLVSTIEN bit was set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transfer has started in Slave 3-wire mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: It will be cleared automatically when a transaction is done or by writing 1 to this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: It is a mutual mirror bit of SPI_STATUS[11].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">SSINAIEN   </td><td class="markdownTableBodyLeft">Slave Select Inactive Interrupt Option (Slave Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This setting is only available if the SPI controller is configured as level trigger in slave device.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31]   </td><td class="markdownTableBodyCenter">DIVMOD   </td><td class="markdownTableBodyLeft">Clock Configuration Backward Compatible Option    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The clock configuration is backward compatible.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The clock configuration is not backward compatible.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Refer to the description of SPI_CLKDIV register for details.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09199">9199</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gab048babf359e75b9245fda37e24f5e8f" name="gab048babf359e75b9245fda37e24f5e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab048babf359e75b9245fda37e24f5e8f">&#9670;&nbsp;</a></span>SSCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::SSCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md222"></a>
SSCTL</h1>
<h2><a class="anchor" id="autotoc_md223"></a>
Offset: 0x08  SPI Slave Select Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">SS   </td><td class="markdownTableBodyLeft">Slave Select Control Bits (Master Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit is 0,    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Set the SPI_SS line to inactive state.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Set the SPI_SS line to active state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If AUTOSS bit is 1,    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Keep the SPI_SS line at inactive state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Select the SPI_SS line to be automatically driven to active state for the duration of transmission/reception, and will be driven to inactive state for the rest of the time.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The active state of SPI_SS is specified in SSACTPOL bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">SSACTPOL   </td><td class="markdownTableBodyLeft">Slave Select Active Level (Slave Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It defines the active status of slave select signal (SPI_SS).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If SSLTEN bit is 1:    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The slave select signal SPI_SS is active at low-level.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The slave select signal SPI_SS is active at high-level.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If SSLTEN bit is 0:    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The slave select signal SPI_SS is active at falling-edge.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The slave select signal SPI_SS is active at rising-edge.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">AUTOSS   </td><td class="markdownTableBodyLeft">Automatic Slave Selection Function Enable Bit (Master Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = SPI_SS pin signal will be asserted/de-asserted by setting /clearing SS bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = SPI_SS pin signal will be generated automatically by hardware, which means that slave select signal will be asserted by the SPI controller when transmit/receive is started by setting SPIEN, and will be de-asserted after each transmit/receive is finished.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">SSLTEN   </td><td class="markdownTableBodyLeft">Slave Select Level Trigger Enable Bit (Slave Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The input slave select signal is edge-trigger.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The input slave select signal is level-trigger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[5]   </td><td class="markdownTableBodyCenter">LTF   </td><td class="markdownTableBodyLeft">Level Trigger Flag (Read Only, Slave Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the SSLTEN bit is set in Slave mode, this bit can be read to indicate the received bit number is met the requirement or not.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transaction number or the transferred bit length of one transaction does not meet the specified requirements.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transaction number and the transferred bit length meet the specified requirements which defined in DWIDTH.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09114">9114</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga6c6fa770a24a0372013c38701a9a4e4b" name="ga6c6fa770a24a0372013c38701a9a4e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c6fa770a24a0372013c38701a9a4e4b">&#9670;&nbsp;</a></span>STATUS <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ACMP_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md2"></a>
STATUS</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Offset: 0x08  Analog Comparator 0/1 Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ACMPIF0   </td><td class="markdownTableBodyLeft">Analog Comparator 0 Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware whenever the comparator 0 output changes state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This will generate an interrupt if ACMPIE (ACMP_CTL0[1]) = 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Analog comparator 0 output does not change.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Analog comparator 0 output changed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared to 0 by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ACMPIF1   </td><td class="markdownTableBodyLeft">Analog Comparator 1 Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware whenever the comparator 1 output changes state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This will generate an interrupt if ACMPIE (ACMP_CTL1[1]) = 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Analog comparator 1 output does not change.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Analog comparator 1 output changed.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared to 0 by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">ACMPO0   </td><td class="markdownTableBodyLeft">Analog Comparator 0 Output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Synchronized to the APB clock to allow reading by software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Cleared when the comparator 0 is disabled ACMPEN (ACMP_CTL0[0]) = 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Analog comparator 0 outputs 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Analog comparator 0 outputs 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">ACMPO1   </td><td class="markdownTableBodyLeft">Analog Comparator 1 Output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Synchronized to the APB clock to allow reading by software.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Cleared when the comparator 1 is disabled ACMPEN (ACMP_CTL1[0]) = 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Analog comparator 1 outputs 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Analog comparator 1 outputs 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00245">245</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga000cdb41ff688b3d840f8f3830a6298c" name="ga000cdb41ff688b3d840f8f3830a6298c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga000cdb41ff688b3d840f8f3830a6298c">&#9670;&nbsp;</a></span>STATUS <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md16"></a>
STATUS</h1>
<h2><a class="anchor" id="autotoc_md17"></a>
Offset: 0x30  A/D Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">ADIF   </td><td class="markdownTableBodyLeft">A/D Conversion End Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">A status flag that indicates the end of A/D conversion. ADIF is set to 1 When A/D conversion ends.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared to 0 by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">ADCMPF0   </td><td class="markdownTableBodyLeft">A/D Compare Flag 0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the selected channel A/D conversion result meets the setting condition in ADC_CMP0, this bit is set to 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Conversion result in ADC_DAT does not meet the ADC_CMP0 setting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Conversion result in ADC_DAT meets the ADC_CMP0 setting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared to 0 by software writing 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">ADCMPF1   </td><td class="markdownTableBodyLeft">A/D Compare Flag 1    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the selected channel A/D conversion result meets the setting condition in ADC_CMP1, this bit is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Conversion result in ADC_DAT does not meet the ADC_CMP1 setting.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Conversion result in ADC_DAT meets the ADC_CMP1 setting.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared to 0 by software writing 1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">BUSY   </td><td class="markdownTableBodyLeft">BUSY/IDLE (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is mirror of as SWTRG bit in ADC_CTL    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = A/D converter is in idle state.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = A/D converter is busy at conversion.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[6:4]   </td><td class="markdownTableBodyCenter">CHANNEL   </td><td class="markdownTableBodyLeft">Current Conversion Channel (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This filed reflects the current conversion channel when BUSY=1.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When BUSY=0, it shows the number of the next converted channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[8]   </td><td class="markdownTableBodyCenter">VALID   </td><td class="markdownTableBodyLeft">Data Valid Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is a mirror of VALID bit in ADC_DAT register.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">OV   </td><td class="markdownTableBodyLeft">Overrun Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is a mirror to OV bit in ADC_DAT register.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00520">520</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga8920dbbf2ea9a13672cd2811d4b2e84b" name="ga8920dbbf2ea9a13672cd2811d4b2e84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8920dbbf2ea9a13672cd2811d4b2e84b">&#9670;&nbsp;</a></span>STATUS <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t CLK_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md34"></a>
STATUS</h1>
<h2><a class="anchor" id="autotoc_md35"></a>
Offset: 0x0C  Clock Status Monitor Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">XTLSTB   </td><td class="markdownTableBodyLeft">HXT Or LXT Clock Source Stable Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HXT or LXT clock is not stable or disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HXT or LXT clock is stable and enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">PLLSTB   </td><td class="markdownTableBodyLeft">Internal PLL Clock Source Stable Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Internal PLL clock is not stable or disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Internal PLL clock is stable and enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">LIRCSTB   </td><td class="markdownTableBodyLeft">LIRC Clock Source Stable Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = LIRC clock is not stable or disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = LIRC clock is stable and enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">HIRCSTB   </td><td class="markdownTableBodyLeft">HIRC Clock Source Stable Flag (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = HIRC clock is not stable or disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = HIRC clock is stable and enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">CLKSFAIL   </td><td class="markdownTableBodyLeft">Clock Switch Fail Flag (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is updated when software switches system clock source.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If switch target clock is stable, this bit will be set to 0.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">If switch target clock is not stable, this bit will be set to .    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Clock switching success.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Clock switching failure.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is read only.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">After selected clock source is stable, hardware will switch system clock to selected clock automatically, and CLKSFAIL will be cleared automatically by hardware.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00973">973</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga45e9c068d3cc966e206bd45c9b04b074" name="ga45e9c068d3cc966e206bd45c9b04b074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45e9c068d3cc966e206bd45c9b04b074">&#9670;&nbsp;</a></span>STATUS <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__I uint32_t I2C_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md90"></a>
STATUS</h1>
<h2><a class="anchor" id="autotoc_md91"></a>
Offset: 0x0C  I2C Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">STATUS   </td><td class="markdownTableBodyLeft">I2C Status Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The three least significant bits are always 0.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The five most significant bits contain the status code.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">There are 26 possible status codes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When I2C_STATUS contains F8H, no serial interrupt is requested.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">All the other I2C_STATUS values correspond to defined I2C states.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When each of these states is entered, a status interrupt is requested (SI = 1).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">A valid status code is present in I2C_STATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In addition, the states 00H stands for a Bus Error.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Examples of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04636">4636</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga4afe2cb0c518f0dff54c05986b987f33" name="ga4afe2cb0c518f0dff54c05986b987f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4afe2cb0c518f0dff54c05986b987f33">&#9670;&nbsp;</a></span>STATUS <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t SPI_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md232"></a>
STATUS</h1>
<h2><a class="anchor" id="autotoc_md233"></a>
Offset: 0x44  SPI Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">RXTHIF   </td><td class="markdownTableBodyLeft">Receive FIFO Threshold Interrupt Status (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The valid data count within the receive FIFO buffer is less than or equal to the setting value of RXTH.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If RXTHIEN = 1 and RXTHIF = 1, the SPI controller will generate a SPI interrupt request.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">RXOVIF   </td><td class="markdownTableBodyLeft">Receive FIFO Overrun Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No overrun in receive FIFO.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Overrun in receive FIFO.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be cleared by writing 1 to itself.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">TXTHIF   </td><td class="markdownTableBodyLeft">Transmit FIFO Threshold Interrupt Status (Read Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: If TXTHIEN = 1 and TXTHIF = 1, the SPI controller will generate a SPI interrupt request.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[11]   </td><td class="markdownTableBodyCenter">SLVSTIF   </td><td class="markdownTableBodyLeft">Slave Start Interrupt Status (Slave Only)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">It is used to dedicate that the transfer has started in slave 3-wire mode.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Slave does not detect any SPI bus clock transfer since the SLVSTIEN bit was set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The transfer is not started.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transfer has started in Slave 3-wire mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: It will be cleared as transfer done or by writing one to this bit.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: It's a mutual mirror bit of SPI_SLVCTL[11].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:12]   </td><td class="markdownTableBodyCenter">RXCNT   </td><td class="markdownTableBodyLeft">Receive FIFO Data Count (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Indicates the valid data count of receive FIFO buffer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[16]   </td><td class="markdownTableBodyCenter">UNITIF   </td><td class="markdownTableBodyLeft">SPI Unit-transfer Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transfer does not finish yet.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The SPI controller has finished one unit transfer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 1: This bit will be cleared by writing 1 to itself.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note 2: It's a mutual mirror bit of SPI_CTL[16].    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[20]   </td><td class="markdownTableBodyCenter">SLVTOIF   </td><td class="markdownTableBodyLeft">Time-out Interrupt Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No receive FIFO time-out event.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The receive FIFO buffer is not empty and it does not be read over 64 SPI clock periods in Master mode or over 576 SPI peripheral clock periods in Slave mode.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When the received FIFO buffer is read by software, the time-out status will be cleared automatically.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit will be cleared by writing 1 to itself.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[24]   </td><td class="markdownTableBodyCenter">RXEMPTY   </td><td class="markdownTableBodyLeft">Receive FIFO Buffer Empty Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The receive FIFO buffer is not empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The receive FIFO buffer is empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It's a mutual mirror bit of SPI_CTL[24].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[25]   </td><td class="markdownTableBodyCenter">RXFULL   </td><td class="markdownTableBodyLeft">Receive FIFO Buffer Full Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The receive FIFO buffer is not full.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The receive FIFO buffer is full.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It's a mutual mirror bit of SPI_CTL[25].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[26]   </td><td class="markdownTableBodyCenter">TXEMPTY   </td><td class="markdownTableBodyLeft">Transmit FIFO Buffer Empty Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmit FIFO buffer is not empty.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmit FIFO buffer is empty.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It's a mutual mirror bit of SPI_CTL[26].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[27]   </td><td class="markdownTableBodyCenter">TXFULL   </td><td class="markdownTableBodyLeft">Transmit FIFO Buffer Full Indicator (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = The transmit FIFO buffer is not full.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = The transmit FIFO buffer is full.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: It's a mutual mirror bit of SPI_CTL[27].    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:28]   </td><td class="markdownTableBodyCenter">TXCNT   </td><td class="markdownTableBodyLeft">Transmit FIFO Data Count (Read Only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Indicates the valid data count of transmit FIFO buffer.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09295">9295</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga2e0ba9ab7857275c7d7d9d9d2c78cdd7" name="ga2e0ba9ab7857275c7d7d9d9d2c78cdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e0ba9ab7857275c7d7d9d9d2c78cdd7">&#9670;&nbsp;</a></span>STATUS <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t WWDT_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md312"></a>
STATUS</h1>
<h2><a class="anchor" id="autotoc_md313"></a>
Offset: 0x08  WWDT Status Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WWDTIF   </td><td class="markdownTableBodyLeft">WWDT Compare Match Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the interrupt flag status of WWDT while WWDT counter value matches CMPDAT (WWDT_CTL[21:16]).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = No effect.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WWDT counter value matches CMPDAT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">WWDTRF   </td><td class="markdownTableBodyLeft">WWDT Timer-out Reset Flag    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the system has been reset by WWDT time-out reset or not.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = WWDT time-out reset did not occur.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = WWDT time-out reset occurred.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit is cleared by writing 1 to it.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11605">11605</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga6c9030c603fea9963d088d0d20de4c1a" name="ga6c9030c603fea9963d088d0d20de4c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9030c603fea9963d088d0d20de4c1a">&#9670;&nbsp;</a></span>STATUS1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::STATUS1</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md112"></a>
STATUS1</h1>
<h2><a class="anchor" id="autotoc_md113"></a>
Offset: 0x40  I2C Status Register 1</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">WKIF   </td><td class="markdownTableBodyLeft">I2C Wake-up Interrupt Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">When chip is woken up from Power-down mode by I2C, this bit is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit can be cleared by software writing "1".    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: Only I2C0 channel supports wake-up function. This bit is not valid on I2C1 channel.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">FULL   </td><td class="markdownTableBodyLeft">I2C Two-level Buffer Full    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates if the TX buffer is full or not when the TWOLVFIFO = 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">EMPTY   </td><td class="markdownTableBodyLeft">I2C Two-level Buffer Empty    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates if the RX buffer is empty or not when the TWOLVFIFO = 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3]   </td><td class="markdownTableBodyCenter">OVIF   </td><td class="markdownTableBodyLeft">I2C Overrun Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the received buffer is overrun when the TWOLVFIFO = 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[4]   </td><td class="markdownTableBodyCenter">URIF   </td><td class="markdownTableBodyLeft">I2C Under Run Status    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit indicates the transmitted buffer is under run when the TWOLVFIFO = 1.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04834">4834</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga3195879cd62ffb1cef35e1a06313fbad" name="ga3195879cd62ffb1cef35e1a06313fbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3195879cd62ffb1cef35e1a06313fbad">&#9670;&nbsp;</a></span>TOCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t I2C_T::TOCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md94"></a>
TOCTL</h1>
<h2><a class="anchor" id="autotoc_md95"></a>
Offset: 0x14  I2C Time-out Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[0]   </td><td class="markdownTableBodyCenter">TOIF   </td><td class="markdownTableBodyLeft">Time-out Flag    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (INTEN) is set to 1.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: This bit can be cleared by software writing '1'.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[1]   </td><td class="markdownTableBodyCenter">TOCURIEN   </td><td class="markdownTableBodyLeft">Time-out Counter Input Clock Divided By 4    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Time-out counter input clock divided by 4 Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time-out counter input clock divided by 4 Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When enabled, the time-out period is extended 4 times.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">[2]   </td><td class="markdownTableBodyCenter">TOCEN   </td><td class="markdownTableBodyLeft">Time-out Counter Enable Bit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Time-out counter Disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Time-out counter Enabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Note: When the 14-bit time-out counter is enabled, it will start counting when SI is cleared.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Setting 1 to the SI flag will reset counter and re-start up counting after SI is cleared.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l04671">4671</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga867050f2a4553c426a3e7a35e7731825" name="ga867050f2a4553c426a3e7a35e7731825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga867050f2a4553c426a3e7a35e7731825">&#9670;&nbsp;</a></span>TOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UART_T::TOUT</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md294"></a>
TOUT</h1>
<h2><a class="anchor" id="autotoc_md295"></a>
Offset: 0x20  UART Time-out Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">TOIC   </td><td class="markdownTableBodyLeft">Time-out Interrupt Comparator    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Once the content of time-out counter (TOUT_CNT) is equal to that of time-out interrupt comparator (TOIC), a receiver time-out interrupt (RXTOINT) is generated if RXTOIEN (UART_INTEN[4]) is enabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">A new incoming data word or RX FIFO empty clears RXTOINT.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfe.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[15:8]   </td><td class="markdownTableBodyCenter">DLY   </td><td class="markdownTableBodyLeft">TX Delay Time Value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">This field is used to program the transfer delay time between the last stop bit and next start bit.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Unit is bit tim.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l11068">11068</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga26ad274ad68871fab0d061481079c4ec" name="ga26ad274ad68871fab0d061481079c4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ad274ad68871fab0d061481079c4ec">&#9670;&nbsp;</a></span>TRGDLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ADC_T::TRGDLY</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md18"></a>
TRGDLY</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
Offset: 0x44  A/D Trigger Delay Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7:0]   </td><td class="markdownTableBodyCenter">DELAY   </td><td class="markdownTableBodyLeft">PWM Trigger Delay Timer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Set this field will delay ADC start conversion time after PWM trigger.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">PWM trigger delay time is (4 * DELAY) * system clock.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00537">537</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="ga3bc2ae73eb2150a611415d9daa5fcdec" name="ga3bc2ae73eb2150a611415d9daa5fcdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bc2ae73eb2150a611415d9daa5fcdec">&#9670;&nbsp;</a></span>TX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__O uint32_t SPI_T::TX</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md226"></a>
TX</h1>
<h2><a class="anchor" id="autotoc_md227"></a>
Offset: 0x20  SPI Data Transmit Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[31:0]   </td><td class="markdownTableBodyCenter">TX   </td><td class="markdownTableBodyLeft">Data Transmit Register    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">The Data Transmit Register holds the data to be transmitted in the next transfer.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Valid bits depend on the transmit bit length field DWIDTH in the SPI_CTL register.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">For example, if DWIDTH is set to 0x08, the bit filed TX[7:0] will be transmitted in next transfer.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l09152">9152</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
<a id="gad821237c92ce9b8df69e97db76bd04e8" name="gad821237c92ce9b8df69e97db76bd04e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad821237c92ce9b8df69e97db76bd04e8">&#9670;&nbsp;</a></span>VREF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t ACMP_T::VREF</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="autotoc_md4"></a>
VREF</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Offset: 0x0C  Analog Comparator Reference Voltage Control Register</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Bits   </th><th class="markdownTableHeadCenter">Field   </th><th class="markdownTableHeadLeft">Descriptions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[3:0]   </td><td class="markdownTableBodyCenter">CRVCTL   </td><td class="markdownTableBodyLeft">Comparator Reference Voltage Control    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">Comparator reference voltage = AVDD * (1 / 6 + CRVCTL(ACMP_VREF[3:0]) / 24).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">[7]   </td><td class="markdownTableBodyCenter">IREFSEL   </td><td class="markdownTableBodyLeft">CRV Internal Reference Selection    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">0 = Band-gap voltage.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyLeft">1 = Internal comparator reference voltage.   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/d13/_mini58_series_8h_source.html#l00260">260</a> of file <a class="el" href="../../d8/d13/_mini58_series_8h_source.html">Mini58Series.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 18 2024 17:16:00 for MINI58_BSP by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
